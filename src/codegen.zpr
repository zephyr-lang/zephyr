import "std/core.zpr";
import "std/io.zpr";
import "std/math.zpr";
import "src/ast.zpr";

namespace Codegen {

const INT_ARG_COUNT = 6;
const FLOAT_ARG_COUNT = 6;
var INT_ARG_REGISTERS: i8*[Codegen::INT_ARG_COUNT] = [ "rdi", "rsi", "rdx", "rcx", "r8", "r9" ];
var FLOAT_ARG_REGISTERS: i8*[Codegen::FLOAT_ARG_COUNT] = [ "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7" ];
var labelCount = 0;
var intRegistersInUse = 0;
var floatRegistersInUse = 0;
var continueLabel = 0;
var breakLabel = 0;

var parser: Parser*;

function Type.qualifier(): i8* {
	when(this.size()) {
		1 -> return "BYTE";
		2 -> return "WORD";
		4 -> return "DWORD";
		8 -> return "QWORD";
	}

	// Structs are interpreted as pointers which are 8 bytes
	return "QWORD";
}

function Type.rax_subregister(): i8* {
	when(this.size()) {
		1 -> return "al";
		2 -> return "ax";
		4 -> return "eax";
		8 -> return "rax";
	}

	// Structs are interpreted as pointers which are 8 bytes
	return "rax";
}

function Type.movzx(): i8* {
	if(this.size() == 1 || this.size() == 2) {
		return "movzx";
	}
	return "mov";
}

function Type.movzx_rax_subregister(): i8* {
	if(this.size() == 4) return "eax";
	return "rax";
}

function Type.reserve(): i8* {
	when(this.size()) {
		1 -> return "resb";
		2 -> return "resw";
		4 -> return "resd";
		8 -> return "resq";
	}

	// Structs are interpreted as pointers which are 8 bytes
	return "resq";
}

function Node.expr_type(): Type* {
	if(this.type == NodeType::SIZEOF) {
		return INT_TYPE;
	}
	else if(this.type == NodeType::ADDROF) {
		var indr = copy_type(this.unary.computedType);
		indr.indirection++;
		return indr;
	}
	return this.computedType;
}

function cmp_suffix(type: int): i8* {
	when(type) {
		NodeType::EQUAL -> return "e";
		NodeType::NOT_EQUAL -> return "ne";
		NodeType::LESS -> return "l";
		NodeType::LESS_EQ -> return "le";
		NodeType::GREATER -> return "g";
		NodeType::GREATER_EQ -> return "ge";
	}

	eputs("Unsupported type in cmp_suffix - "); eputs(node_type_to_string(type)); eputln();
	exit(1);
	return null;
}

function ucmp_suffix(type: int): i8* {
	when(type) {
		NodeType::EQUAL -> return "e";
		NodeType::NOT_EQUAL -> return "ne";
		NodeType::LESS -> return "b";
		NodeType::LESS_EQ -> return "na";
		NodeType::GREATER -> return "a";
		NodeType::GREATER_EQ -> return "nb";
	}

	eputs("Unsupported type in ucmp_suffix - "); eputs(node_type_to_string(type)); eputln();
	exit(1);
	return null;
}

function generate_addrof(expr: Node*, out: File*) {
	when(expr.unary.lvalue) {
		LValue::LOCAL -> {
			out.puts("    lea rax, [rbp-"); out.putd(expr.unary.variable.stackOffset); out.putsln("]");
		}
		LValue::GLOBAL -> {
			out.puts("    lea rax, [_G"); out.put_name(&expr.unary.variable.name); out.putsln("]");
		}
		LValue::SUBSCRIPT -> {
			generate_expr(expr.unary.binary.lhs, out);
			out.putsln("    push rax");
			generate_expr(expr.unary.binary.rhs, out);
			out.putsln("    mov rcx, rax");
			out.putsln("    pop rax");

			//FIXME: This could make array accessing very slow
			var size = expr.unary.computedType.size();
			if(size % 2 != 0 || size == 6 || size > 8) {
				out.puts("    imul rcx, "); out.putu(size); out.putln();
				out.putsln("    add rax, rcx");
				out.putsln("    lea rax, [rax]");
			}
			else {
				out.puts("    lea rax, [rax+rcx*"); out.putd(size); out.putsln("]");
			}
		}
		LValue::MEMBER -> {
			generate_expr(expr.unary.member.parent, out);
			var field = expr.unary.member.memberRef;
			out.puts("    lea rax, [rax+"); out.putd(field.variable.stackOffset); out.putsln("]");
		}
		else -> {
			eputs("Unsupported lvalue in generate_addrof_rax - "); eputd(expr.unary.lvalue); eputln();
			exit(1);
		}
	}
}

function generate_deref(expr: Node*, out: File*) {
	if(expr.computedType.is_structural()) {
		generate_lvalue(expr, out);
		return;
	}

	generate_expr(expr.unary, out);

	out.puts("    "); out.puts(expr.computedType.movzx()); out.puts(" "); out.puts(expr.computedType.movzx_rax_subregister()); out.puts(", ");
	out.puts(expr.computedType.qualifier()); out.putsln(" [rax]");
}

function generate_unary(expr: Node*, out: File*) {
	when(expr.type) {
		NodeType::BWNOT -> {
			generate_expr(expr.unary, out);
			out.putsln("    not rax");
		}
		NodeType::NEG -> {
			generate_expr(expr.unary, out);
			if(expr.computedType.is_float()) {
				out.putsln("    xorps xmm1, xmm1");
				out.putsln("    subps xmm1, xmm0");
				out.putsln("    movsd xmm0, xmm1");
			}
			else {
				out.putsln("    neg rax");
			}
		}
		NodeType::NOT -> {
			generate_expr(expr.unary, out);
			out.putsln("    test rax, rax");
			out.putsln("    sete al");
			out.putsln("    movzx rax, al");
		}
		NodeType::ADDROF -> {
			generate_addrof(expr, out);
		}
		NodeType::DEREF -> {
			generate_deref(expr, out);
		}
		else -> {
			eputs("Unsupported type in generate_unary_rax - "); eputs(node_type_to_string(expr.type)); eputln();
			exit(1);
		}
	}
}

function generate_logical_or(expr: Node*, out: File*) {
	var label = labelCount = labelCount + 1;
	generate_expr(expr.binary.lhs, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    mov rax, 1");
	out.putsln("    test rcx, rcx");
	out.puts("    jne .l"); out.putd(label); out.putln();
	generate_expr(expr.binary.rhs, out);
	out.putsln("    test rax, rax");
	out.putsln("    setne al");
	out.putsln("    movzx rax, al");
	out.puts(".l"); out.putd(label); out.putsln(":");
}

function generate_logical_and(expr: Node*, out: File*) {
	var label = labelCount = labelCount + 1;
	generate_expr(expr.binary.lhs, out);
	out.putsln("    test rax, rax");
	out.puts("    je .l"); out.putd(label); out.putln();
	generate_expr(expr.binary.rhs, out);
	out.putsln("    test rax, rax");
	out.putsln("    setne al");
	out.putsln("    movzx rax, al");
	out.puts(".l"); out.putd(label); out.putsln(":");
}

function generate_binary_float_arith(expr: Node*, out: File*) {
	generate_expr(expr.binary.lhs, out);
	out.putsln("    sub rsp, 8");
	out.putsln("    movsd [rsp], xmm0");
	generate_expr(expr.binary.rhs, out);
	out.putsln("    movsd xmm1, [rsp]");
	out.putsln("    add rsp, 8");

	var op: i8*;
	when(expr.type) {
		NodeType::ADD -> {
			op = "addsd";
		}
		NodeType::SUB -> {
			op = "subsd";
		}
		NodeType::MUL -> {
			op = "mulsd";
		}
		NodeType::DIV -> {
			op = "divsd";
		}
		else -> {
			eputsln("Unreachable - generate_binary_float_arith");
			exit(1);
		}
	}

	out.puts("    "); out.puts(op); out.putsln(" xmm1, xmm0");
	out.putsln("    movsd xmm0, xmm1");
}

function generate_float_comparison(expr: Node*, out: File*) {
	generate_expr(expr.binary.lhs, out);
	out.putsln("    sub rsp, 8");
	out.putsln("    movsd [rsp], xmm0");
	generate_expr(expr.binary.rhs, out);
	out.putsln("    movsd xmm1, xmm0");
	out.putsln("    movsd xmm0, [rsp]");
	out.putsln("    add rsp, 8");
	out.putsln("    ucomisd xmm0, xmm1");
}

function generate_binary(expr: Node*, out: File*) {
	if(expr.type == NodeType::OR) {
		generate_logical_or(expr, out);
		return;
	}
	else if(expr.type == NodeType::AND) {
		generate_logical_and(expr, out);
		return;
	}

	if(expr.computedType.is_float()) {
		assert(is_float_arithmetic(expr.type), "Invalid floating point operation in generate_binary");

		generate_binary_float_arith(expr, out);
		return;
	}

	if(is_comparison(expr.type) && expr.binary.lhs.computedType.is_float()) {
		assert(expr.binary.rhs.computedType.is_float(), "Both sides of float operation must be floats - generate_binary");

		generate_float_comparison(expr, out);
		out.puts("    set"); out.puts(ucmp_suffix(expr.type)); out.putsln(" al");
		out.putsln("    movzx rax, al");
		return;
	}

	generate_expr(expr.binary.lhs, out);
	out.putsln("    push rax");
	generate_expr(expr.binary.rhs, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    pop rax");

	when(expr.type) {
		NodeType::ADD -> {
			out.putsln("    add rax, rcx");
		}
		NodeType::SUB -> {
			out.putsln("    sub rax, rcx");
		}
		NodeType::MUL -> {
			out.putsln("    imul rax, rcx");
		}
		NodeType::DIV -> {
			if(expr.computedType.is_unsigned()) {
				out.putsln("    mov rdx, 0");
				out.putsln("    div rcx");
			} else {
				out.putsln("    cqo");
				out.putsln("    idiv rcx");
			}
		}
		NodeType::MOD -> {
			if(expr.computedType.is_unsigned()) {
				out.putsln("    mov rdx, 0");
				out.putsln("    div rcx");
			} else {
				out.putsln("    cqo");
				out.putsln("    idiv rcx");
			}
			out.putsln("    mov rax, rdx");
		}
		NodeType::BWAND -> {
			out.putsln("    and rax, rcx");
		}
		NodeType::BWOR -> {
			out.putsln("    or rax, rcx");
		}
		NodeType::XOR -> {
			out.putsln("    xor rax, rcx");
		}
		NodeType::LSH -> {
			out.putsln("    sal rax, cl");
		}
		NodeType::RSH -> {
			if(expr.computedType.is_unsigned())
				out.putsln("    shr rax, cl");
			else
				out.putsln("    sar rax, cl");
		}
		NodeType::EQUAL, NodeType::NOT_EQUAL, NodeType::LESS, NodeType::LESS_EQ, NodeType::GREATER, NodeType::GREATER_EQ -> {
			out.putsln("    cmp rax, rcx");
			out.puts("    set"); out.puts(expr.computedType.is_unsigned() ? ucmp_suffix(expr.type) : cmp_suffix(expr.type)); out.putsln(" al");
			out.putsln("    movzx rax, al");
		}
		else -> {
			eputs("Unsupported type in generate_binary_rax - "); eputs(node_type_to_string(expr.type)); eputln();
			exit(1);
		}
	}
}

function generate_call(expr: Node*, out: File*) {
	for(var i = 0; i < intRegistersInUse; ++i) {
		out.puts("    push "); out.putsln(INT_ARG_REGISTERS[i]);
	}
	for(var i = 0; i < floatRegistersInUse; ++i) {
		out.putsln("    sub rsp, 8");
		out.puts("    movsd [rsp], "); out.putsln(FLOAT_ARG_REGISTERS[i]);
	}

	var localIntRegUse = 0;
	var localFloatRegUse = 0;

	for(var i = 0; i < expr.funktion.arguments.size; ++i) {
		var arg: Node* = expr.funktion.arguments.at(i);

		if(arg.expr_type().is_float()) {
			if(localFloatRegUse < FLOAT_ARG_COUNT) {
				generate_expr(arg, out);
				out.puts("    movsd "); out.puts(FLOAT_ARG_REGISTERS[localFloatRegUse]); out.putsln(", xmm0");
				++floatRegistersInUse;
				++localFloatRegUse;
			}
			else {
				generate_expr(arg, out);
				out.putsln("    sub rsp, 8");
				out.putsln("    movsd [rsp], xmm0");
			}
		}
		else {
			if(localIntRegUse < INT_ARG_COUNT) {
				generate_expr(arg, out);
				out.puts("    mov "); out.puts(INT_ARG_REGISTERS[localIntRegUse]); out.putsln(", rax");
				++intRegistersInUse;
				++localIntRegUse;
			}
			else {
				generate_expr(arg, out);
				out.putsln("    push rax");
			}
		}
	}

	intRegistersInUse -= localIntRegUse;
	floatRegistersInUse -= localFloatRegUse;

	out.puts("    call _F"); out.put_name(&expr.funktion.name); out.putln();

	for(var i = 0; i < intRegistersInUse; ++i) {
		out.puts("    pop "); out.putsln(INT_ARG_REGISTERS[intRegistersInUse - i - 1]);
	}

	for(var i = 0; i < floatRegistersInUse; ++i) {
		out.puts("    movsd "); out.puts(FLOAT_ARG_REGISTERS[floatRegistersInUse - i - 1]); out.putsln(", [rsp]");
		out.putsln("    add rsp, 8");
	}
}

function generate_method_call(parent: Node*, parentType: Type*, name: Name*, arguments: Vector*, out: File*) {
	for(var i = 0; i < intRegistersInUse; ++i) {
		out.puts("    push "); out.putsln(INT_ARG_REGISTERS[i]);
	}
	for(var i = 0; i < floatRegistersInUse; ++i) {
		out.putsln("    sub rsp, 8");
		out.puts("    movsd [rsp], "); out.putsln(FLOAT_ARG_REGISTERS[i]);
	}

	var localIntRegUse = 1;
	var localFloatRegUse = 0;
	++intRegistersInUse;
	
	if(parent != null)
		generate_expr(parent, out);
	out.putsln("    mov rdi, rax");

	if(arguments != null) {
		for(var i = 0; i < arguments.size; ++i) {
			var arg: Node* = arguments.at(i);

			if(arg.expr_type().is_float()) {
				if(localFloatRegUse < FLOAT_ARG_COUNT) {
					generate_expr(arg, out);
					out.puts("    movsd "); out.puts(FLOAT_ARG_REGISTERS[localFloatRegUse]); out.putsln(", xmm0");
					++floatRegistersInUse;
					++localFloatRegUse;
				}
				else {
					generate_expr(arg, out);
					out.putsln("    sub rsp, 8");
					out.putsln("    movsd [rsp], xmm0");
				}
			}
			else {
				if(localIntRegUse < INT_ARG_COUNT) {
					generate_expr(arg, out);
					out.puts("    mov "); out.puts(INT_ARG_REGISTERS[localIntRegUse]); out.putsln(", rax");
					++intRegistersInUse;
					++localIntRegUse;
				}
				else {
					generate_expr(arg, out);
					out.putsln("    push rax");
				}
			}
		}
	}

	intRegistersInUse -= localIntRegUse;
	floatRegistersInUse -= localFloatRegUse;

	out.puts("    call _M"); out.put_name(&parentType.name); out.puts("_"); out.put_name(name);
	out.putln();

	for(var i = 0; i < intRegistersInUse; ++i) {
		out.puts("    pop "); out.putsln(INT_ARG_REGISTERS[intRegistersInUse - i - 1]);
	}

	for(var i = 0; i < floatRegistersInUse; ++i) {
		out.puts("    movsd "); out.puts(FLOAT_ARG_REGISTERS[floatRegistersInUse - i - 1]); out.putsln(", [rsp]");
		out.putsln("    add rsp, 8");
	}
}

function generate_call_method(expr: Node*, out: File*) {
	generate_method_call(expr.funktion.parent, expr.funktion.parentType, &expr.funktion.name, expr.funktion.arguments, out);
}

function generate_ternary(expr: Node*, out: File*) {
	generate_expr(expr.conditional.condition, out);
	out.putsln("    test rax, rax");
	var falseLabel = labelCount = labelCount + 1;
	var endLabel = labelCount = labelCount + 1;

	out.puts("    je .l"); out.putd(falseLabel); out.putln();
	generate_expr(expr.conditional.doTrue, out);
	out.puts("    jmp .l"); out.putd(endLabel); out.putln();

	out.puts(".l"); out.putd(falseLabel); out.putsln(":");
	generate_expr(expr.conditional.doFalse, out);

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
}

function generate_access_var(expr: Node*, out: File*) {
	if(expr.variable.type.isArray || expr.variable.type.is_structural()) {
		out.puts("    lea rax, [rbp-"); out.putd(expr.variable.stackOffset); out.putsln("]");
		return;
	}
	else if(expr.variable.type.is_float()) {
		out.puts("    movsd xmm0, [rbp-"); out.putd(expr.variable.stackOffset); out.putsln("]");
		return;
	}

	out.puts("    "); out.puts(expr.variable.type.movzx()); out.puts(" "); out.puts(expr.variable.type.movzx_rax_subregister()); out.puts(", ");
	out.puts(expr.variable.type.qualifier()); out.puts(" [rbp-"); out.putd(expr.variable.stackOffset); out.putsln("]");
}

function generate_access_global_var(expr: Node*, out: File*) {
	if(expr.variable.type.isArray || expr.variable.type.is_structural()) {
		out.puts("    lea rax, [_G"); out.put_name(&expr.variable.name); out.putsln("]");
		return;
	}

	out.puts("    "); out.puts(expr.variable.type.movzx()); out.puts(" "); out.puts(expr.variable.type.rax_subregister()); out.puts(", ");
	out.puts(expr.variable.type.qualifier()); out.puts(" [_G"); out.put_name(&expr.variable.name); out.putsln("]");
}

function generate_access_subscript(expr: Node*, out: File*) {
	generate_lvalue(expr, out);

	if(expr.computedType.is_float()) {
		out.putsln("    movsd xmm0, [rax]");
	}
	else if(expr.computedType.is_structural()) {
		// Load as pointer
	}
	else {
		out.puts("    "); out.puts(expr.computedType.movzx()); out.puts(" "); out.puts(expr.computedType.movzx_rax_subregister());
		out.puts(", "); out.puts(expr.computedType.qualifier()); out.putsln(" [rax]");
	}
}

function generate_access_member(expr: Node*, out: File*) {
	generate_expr(expr.member.parent, out);
	var field = expr.member.memberRef;
	
	if(field.variable.type.isArray || field.variable.type.is_structural()) {
		out.puts("    lea rax, [rax+"); out.putd(field.variable.stackOffset); out.putsln("]");
	}
	else if(field.variable.type.is_float()) {
		out.puts("    movsd xmm0, [rax+"); out.putd(field.variable.stackOffset); out.putsln("]");
	}
	else {
		out.puts("    "); out.puts(field.variable.type.movzx()); out.puts(" "); out.puts(field.variable.type.movzx_rax_subregister());
		out.puts(", "); out.puts(field.variable.type.qualifier()); out.puts(" [rax+"); out.putd(field.variable.stackOffset); out.putsln("]");
	}
}

function generate_copy(fields: Vector*, parentOffset: int, out: File*) {
	for(var i = 0; i < fields.size; ++i) {
		var field: Node* = fields.at(i);

		if(field.variable.type.is_structural()) {
			generate_copy(field.variable.type.fields, field.variable.stackOffset, out);
			continue;
		}

		out.puts("    mov rdx, "); out.puts(field.variable.type.qualifier()); out.puts(" [rax+"); 
		out.putd(field.variable.stackOffset + parentOffset); out.putsln("]");

		out.puts("    mov "); out.puts(field.variable.type.qualifier()); out.puts(" [rcx+"); 
		out.putd(field.variable.stackOffset + parentOffset); out.putsln("], rdx");
	}
}

function generate_lvalue(expr: Node*, out: File*) {
	when(expr.lvalue) {
		LValue::LOCAL -> {
			out.puts("    lea rax, [rbp-"); out.putd(expr.variable.stackOffset); out.putsln("]");
		}
		LValue::GLOBAL -> {
			out.puts("    lea rax, [_G"); out.put_name(&expr.variable.name); out.putsln("]");
		}
		LValue::SUBSCRIPT -> {
			generate_expr(expr.binary.lhs, out);
			out.putsln("    push rax");
			generate_expr(expr.binary.rhs, out);
			out.putsln("    mov rcx, rax");
			out.putsln("    pop rax");

			//FIXME: This could make array accessing very slow
			var size = expr.computedType.size();
			if(size % 2 != 0 || size == 6 || size > 8) {
				out.puts("    imul rcx, "); out.putu(size); out.putln();
				out.putsln("    add rax, rcx");
				out.putsln("    lea rax, [rax]");
			}
			else {
				out.puts("    lea rax, [rax+rcx*"); out.putd(size); out.putsln("]");
			}
		}
		LValue::DEREF -> {
			generate_expr(expr.unary, out);
		}
		LValue::MEMBER -> {
			generate_expr(expr.member.parent, out);
			var field = expr.member.memberRef;
			
			out.puts("    lea rax, [rax+"); out.putd(field.variable.stackOffset); out.putsln("]");
		}
		else -> {
			eputsln("Unreachable - unknown lvalue in generate_lvalue_rax");
			eputd(expr.lvalue); eputln();
			exit(1);
		}
	}
}

function generate_assign(expr: Node*, out: File*) {
	generate_lvalue(expr.assignment.lhs, out);
	out.putsln("    push rax");
	if(expr.assignment.op.type != TokenType::EQ) {
		expr.assignment.rhs.binary.lhs.type = NodeType::RELATIVE;
	}
	generate_expr(expr.assignment.rhs, out);
	out.putsln("    pop rcx");

	if(expr.computedType.is_structural()) {
		generate_copy(expr.computedType.fields, 0, out);
	}
	else if(expr.computedType.is_float()) {
		out.putsln("    movsd [rcx], xmm0");
	}
	else {
		out.puts("    mov "); out.puts(expr.computedType.qualifier()); out.puts(" [rcx], "); out.putsln(expr.computedType.rax_subregister());
	}
}

function generate_pre_increment(expr: Node*, out: File*) {
	generate_lvalue(expr.unary, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    mov rax, [rax]");
	out.putsln("    add rax, 1");
	out.puts("    mov "); out.puts(expr.computedType.qualifier()); out.puts(" [rcx], "); out.putsln(expr.computedType.rax_subregister());
}

function generate_pre_decrement(expr: Node*, out: File*) {
	generate_lvalue(expr.unary, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    mov rax, [rax]");
	out.putsln("    sub rax, 1");
	out.puts("    mov "); out.puts(expr.computedType.qualifier()); out.puts(" [rcx], "); out.putsln(expr.computedType.rax_subregister());
}

function generate_post_increment(expr: Node*, out: File*) {
	generate_lvalue(expr.unary, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    mov rax, [rax]");
	out.putsln("    mov rdx, rax");
	out.putsln("    add rax, 1");
	out.puts("    mov "); out.puts(expr.computedType.qualifier()); out.puts(" [rcx], "); out.putsln(expr.computedType.rax_subregister());
	out.putsln("   mov rax, rdx");
}

function generate_post_decrement(expr: Node*, out: File*) {
	generate_lvalue(expr.unary, out);
	out.putsln("    mov rcx, rax");
	out.putsln("    mov rax, [rax]");
	out.putsln("    mov rdx, rax");
	out.putsln("    sub rax, 1");
	out.puts("    mov "); out.puts(expr.computedType.qualifier()); out.puts(" [rcx], "); out.putsln(expr.computedType.rax_subregister());
	out.putsln("   mov rax, rdx");
}

function generate_new(expr: Node*, out: File*) {
	// Typecheck should verify that malloc exists with the correct signature
	out.puts("    mov rdi, "); out.putu(expr.constructor.type.size()); out.putln();
	out.putsln("    call _FZmalloc");

	if(expr.constructor.arguments != null) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		parser.bind_name(&constructorName, constructorTok);

		out.putsln("    push rax");
		generate_method_call(null, expr.constructor.type, &constructorName, expr.constructor.arguments, out);
		out.putsln("    pop rax");
	}
}

function generate_new_array(expr: Node*, out: File*) {
	// Typecheck should verify that malloc exists with the correct signature
	generate_expr(expr.constructor.array.length, out);
	if(expr.constructor.array.shouldConstruct) {
		out.putsln("    push rax");
	}
	out.puts("    imul rax, "); out.putu(expr.constructor.type.size()); out.putln();
	out.putsln("    mov rdi, rax");
	out.putsln("    call _FZmalloc");

	// Construct a for-loop inline
	if(expr.constructor.array.shouldConstruct) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		parser.bind_name(&constructorName, constructorTok);

		var loopStart = ++labelCount;
		var loopEnd = ++labelCount;

		out.putsln("    mov rdx, [rsp]"); // Capture the length in rdx
		out.putsln("    push rax");       // push the malloc'd address (changes)
		out.putsln("    push rax");       // push the malloc'd address (static, final result)

		out.putsln("    mov rcx, 0");
		out.putsln("    push rcx");       // push 'i' initialised to 0

		// At the beginning of each iteration, the top of the stack appears as such:
		// - i (iteration)
		// - address (result)
		// - address (offsetted)
		// - length of array

		out.puts(".l"); out.putu(loopStart); out.putsln(":");
		out.putsln("    cmp rcx, rdx");
		out.puts("    jnb .l"); out.putu(loopEnd); out.putln(); // exit the loop if i >= length

		// address (offsetted) is already in rax at this point
		generate_method_call(null, expr.constructor.type, &constructorName, null, out);

		// Set registers as such:
		// rcx - i
		// rax - address (offsetted)
		// rdx - length
		out.putsln("    mov rcx, [rsp]");
		out.putsln("    mov rax, [rsp+16]");
		out.putsln("    mov rdx, [rsp+24]");

		// Increment (and store) i (by 1) and the offsetted address (by the size of an element)
		out.putsln("    add rcx, 1");
		out.putsln("    mov [rsp], rcx");
		out.puts("    add rax, "); out.putu(expr.constructor.type.size()); out.putln();
		out.putsln("    mov [rsp+16], rax");

		// complete the loop
		out.puts("    jmp .l"); out.putu(loopStart); out.putln();

		out.puts(".l"); out.putu(loopEnd); out.putsln(":");
		// Set rax to the final result address (which is the same as the one malloc originally returned)
		// then pop the values from the stack
		out.putsln("    mov rax, [rsp+8]");
		out.putsln("    add rsp, 32");
	}
}

function generate_expr(expr: Node*, out: File*) {
	if(is_unary_op(expr.type)) {
		generate_unary(expr, out);
		return;
	}
	else if(is_binary_op(expr.type)) {
		generate_binary(expr, out);
		return;
	}
	when(expr.type) {
		NodeType::INT_LITERAL -> {
			out.puts("    mov rax, "); out.putd(expr.literal.az.integer); out.putln();
		}
		NodeType::UINT_LITERAL -> {
			out.puts("    mov rax, "); out.putu(expr.literal.az.uinteger); out.putln();
		}
		NodeType::CHAR_LITERAL -> {
			out.puts("    mov rax, "); out.putd(expr.literal.az.integer); out.putln();
		}
		NodeType::FLOAT_LITERAL -> {
			out.puts("    movsd xmm0, [_D"); out.putd(expr.literal.az.float.id); out.putsln("]");
		}
		NodeType::STRING -> {
			out.puts("    lea rax, [_S"); out.putd(expr.literal.az.string.id); out.putsln("]");
		}
		NodeType::ACCESS_VAR -> {
			generate_access_var(expr, out);
		}
		NodeType::ACCESS_GLOBAL_VAR -> {
			generate_access_global_var(expr, out);
		}
		NodeType::CALL -> {
			generate_call(expr, out);
		}
		NodeType::CALL_METHOD -> {
			generate_call_method(expr, out);
		}
		NodeType::TERNARY -> {
			generate_ternary(expr, out);
		}
		NodeType::SIZEOF -> {
			out.puts("    mov rax, "); out.putd(expr.computedType.size_offset()); out.putln();
		}
		NodeType::ACCESS_SUBSCRIPT -> {
			generate_access_subscript(expr, out);
		}
		NodeType::CAST -> {
			generate_expr(expr.unary, out);
		}
		NodeType::ACCESS_MEMBER -> {
			generate_access_member(expr, out);
		}
		NodeType::ASSIGN -> {
			generate_assign(expr, out);
		}
		NodeType::RELATIVE -> {
			if(expr.computedType.is_float()) {
				out.putsln("    movsd xmm0, [rax]");
			}
			else {
				out.putsln("    mov rax, [rax]");
			}
		}
		NodeType::PRE_INCREMENT -> {
			generate_pre_increment(expr, out);
		}
		NodeType::PRE_DECREMENT -> {
			generate_pre_decrement(expr, out);
		}
		NodeType::POST_INCREMENT -> {
			generate_post_increment(expr, out);
		}
		NodeType::POST_DECREMENT -> {
			generate_post_decrement(expr, out);
		}
		NodeType::INT_TO_FLOAT -> {
			generate_expr(expr.unary, out);
			out.putsln("    cvtsi2sd xmm0, rax");
		}
		NodeType::FLOAT_TO_INT -> {
			generate_expr(expr.unary, out);
			out.putsln("    cvttsd2si rax, xmm0");
		}
		NodeType::NEW -> {
			generate_new(expr, out);
		}
		NodeType::NEW_ARRAY -> {
			generate_new_array(expr, out);
		}
		else -> {
			eputs("Unsupported type in generate_expr_rax - "); eputs(node_type_to_string(expr.type)); eputln();
			exit(1);
		}
	}
}

function generate_if_statement(ifStmt: Node*, out: File*) {
	generate_expr(ifStmt.conditional.condition, out);
	out.putsln("    test rax, rax");
	var falseLabel = labelCount = labelCount + 1;
	var endLabel = labelCount = labelCount + 1;

	out.puts("    je .l"); out.putd(falseLabel); out.putln();

	generate_statement(ifStmt.conditional.doTrue, out);

	if(ifStmt.conditional.doFalse != null) {
		out.puts("    jmp .l"); out.putd(endLabel); out.putln();
	}

	out.puts(".l"); out.putd(falseLabel); out.putsln(":");

	if(ifStmt.conditional.doFalse != null) {
		generate_statement(ifStmt.conditional.doFalse, out);
		out.puts(".l"); out.putd(endLabel); out.putsln(":");
	}
}

function generate_while_statement(whileStmt: Node*, out: File*) {
	var condLabel = labelCount = labelCount + 1;
	var bodyLabel = labelCount = labelCount + 1;
	var endLabel = labelCount = labelCount + 1;

	var prevContinueLabel = continueLabel;
	var prevBreakLabel = breakLabel;
	continueLabel = condLabel;
	breakLabel = endLabel;

	out.puts("    jmp .l"); out.putd(condLabel); out.putln();
	out.puts(".l"); out.putd(bodyLabel); out.putsln(":");

	generate_statement(whileStmt.conditional.doTrue, out);

	out.puts(".l"); out.putd(condLabel); out.putsln(":");
	generate_expr(whileStmt.conditional.condition, out);
	out.putsln("    test rax, rax");
	out.puts("    jne .l"); out.putd(bodyLabel); out.putln();

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
	breakLabel = prevBreakLabel;
	continueLabel = prevContinueLabel;
}

function generate_do_while_statement(whileStmt: Node*, out: File*) {
	var condLabel = labelCount = labelCount + 1;
	var bodyLabel = labelCount = labelCount + 1;
	var endLabel = labelCount = labelCount + 1;

	var prevContinueLabel = continueLabel;
	var prevBreakLabel = breakLabel;
	continueLabel = condLabel;
	breakLabel = endLabel;

	out.puts(".l"); out.putd(bodyLabel); out.putsln(":");

	generate_statement(whileStmt.conditional.doTrue, out);

	out.puts(".l"); out.putd(condLabel); out.putsln(":");
	generate_expr(whileStmt.conditional.condition, out);
	out.putsln("    test rax, rax");
	out.puts("    jne .l"); out.putd(bodyLabel); out.putln();

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
	breakLabel = prevBreakLabel;
	continueLabel = prevContinueLabel;
}

function generate_for_statement(forStmt: Node*, out: File*) {
	if(forStmt.loop.initial != null)
		generate_statement(forStmt.loop.initial, out);

	var hasCondition = forStmt.loop.condition != null;
	var condLabel = labelCount = labelCount + 1;
	var bodyLabel = labelCount = labelCount + 1;
	var endLabel = labelCount = labelCount + 1;
	var iterationLabel: int;

	var prevContinueLabel = continueLabel;
	var prevBreakLabel = breakLabel;
	continueLabel = condLabel;
	breakLabel = endLabel;

	if(forStmt.loop.iteration != null) {
		iterationLabel = labelCount = labelCount + 1;
		continueLabel = iterationLabel;
	}

	if(hasCondition) {
		out.puts("    jmp .l"); out.putd(condLabel); out.putln();
	}
	
	out.puts(".l"); out.putd(bodyLabel); out.putsln(":");

	generate_statement(forStmt.loop.body, out);

	if(forStmt.loop.iteration != null) {
		out.puts(".l"); out.putd(iterationLabel); out.putsln(":");
		generate_expr(forStmt.loop.iteration, out);
	}

	if(hasCondition) {
		out.puts(".l"); out.putd(condLabel); out.putsln(":");
		generate_expr(forStmt.loop.condition, out);
		out.putsln("    test rax, rax");
		out.puts("    jne .l"); out.putd(bodyLabel); out.putln();
	}
	else {
		out.puts("    jmp .l"); out.putd(bodyLabel); out.putln();
	}

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
	breakLabel = prevBreakLabel;
	continueLabel = prevContinueLabel;
}

function generate_when_statement(stmt: Node*, out: File*) {
	generate_expr(stmt.vhen.match, out);

	var label = ++labelCount;
	var defaultLabel: int;
	labelCount += stmt.vhen.branches.size;
	defaultLabel = ++labelCount;
	var endLabel = defaultLabel;
	if(stmt.vhen.default != null) endLabel = ++labelCount;

	for(var i = 0; i < stmt.vhen.branches.size; ++i) {
		var case: Node* = stmt.vhen.branches.at(i);

		for(var valI = 0; valI < case.branch.values.size; ++valI) {
			var value = case.branch.values.at(valI) as int;
			out.puts("    cmp rax, "); out.putd(value); out.putln();
			out.puts("    je .l"); out.putd(label + i); out.putln();
		}
	}

	out.puts("    jmp .l"); out.putd(defaultLabel); out.putln();

	for(var i = 0; i < stmt.vhen.branches.size; ++i) {
		var case: Node* = stmt.vhen.branches.at(i);

		out.puts(".l"); out.putd(label + i); out.putsln(":");

		generate_statement(case.branch.body, out);

		out.puts("    jmp .l"); out.putd(endLabel); out.putln();
	}

	if(stmt.vhen.default != null) {
		out.puts(".l"); out.putd(defaultLabel); out.putsln(":");

		generate_statement(stmt.vhen.default, out);
	}

	out.puts(".l"); out.putd(endLabel); out.putsln(":");
}

function generate_define_var(stmt: Node*, out: File*) {
	if(stmt.variable.value != null) {
		if(stmt.variable.value.type == NodeType::ARRAY_INIT) {
			var array = stmt.variable.value;
			var itemType = copy_type(stmt.variable.type);
			itemType.indirection = itemType.indirection - 1;
			for(var i = 0; i < array.block.children.size; ++i) {
				generate_expr(array.block.children.at(i), out);
				
				if(itemType.is_float()) {
					out.puts("    movsd [rbp-"); out.putd(stmt.variable.stackOffset - (i * 8)); out.putsln("], xmm0");
				}
				else {
					out.puts("    mov "); out.puts(itemType.qualifier()); out.puts(" [rbp-"); out.putd(stmt.variable.stackOffset - (i * itemType.size()));
					out.puts("], "); out.putsln(itemType.rax_subregister());
				}
			}
			return;
		}

		generate_expr(stmt.variable.value, out);

		if(stmt.variable.type.is_structural()) {
			out.puts("lea rcx, [rbp-"); out.putd(stmt.variable.stackOffset); out.putsln("]");
			generate_copy(stmt.variable.type.fields, 0, out);
		}
		else if(stmt.variable.type.is_float()) {
			out.puts("    movsd [rbp-"); out.putd(stmt.variable.stackOffset); out.putsln("], xmm0");
		}
		else {
			out.puts("    mov "); out.puts(stmt.variable.type.qualifier()); out.puts(" [rbp-"); out.putd(stmt.variable.stackOffset);
			out.puts("], "); out.putsln(stmt.variable.type.rax_subregister());
		}
	}
}

function generate_delete(stmt: Node*, out: File*) {
	generate_expr(stmt.unary, out);
	out.putsln("    mov rdi, rax");
	out.putsln("    call _FZfree");

	var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
	var deconstructorName: Name;
	parser.bind_name(&deconstructorName, deconstructorTok);

	var deconstructor = stmt.unary.computedType.lookup_method(&deconstructorName);

	if(deconstructor != null) {
		out.puts("    call _M"); out.put_name(&stmt.unary.computedType.name); out.puts("_"); out.put_name(&deconstructorName); out.putln();
	}
}

function generate_delete_array(stmt: Node*, out: File*) {
	generate_expr(stmt.deconstructor.value, out);

	out.putsln("push rax");
	out.putsln("push rax");

	var arrayLengthFunc = parser.resolve_get_array_length_function();
	out.putsln("mov rdi, rax");
	out.puts("mov rsi, "); out.putu(stmt.deconstructor.elementType.size()); out.putln();
	out.puts("call _F"); out.put_name(&arrayLengthFunc.funktion.name); out.putln();

	out.putsln("push rax");

	var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
	var deconstructorName: Name;
	parser.bind_name(&deconstructorName, deconstructorTok);

	var loopStart = ++labelCount;
	var loopEnd = ++labelCount;

	out.putsln("    mov rcx, 0");
	out.putsln("    push rcx");          // push 'i' initialised to 0
	out.putsln("    mov rdx, [rsp+8]");  // move the length into rdx
	out.putsln("    mov rax, [rsp+16]"); // move the address of the array into rax

	// At the beginning of each iteration, the top of the stack appears as such:
	// - i (iteration)
	// - length of array
	// - address (offsetted)
	// - address (result)

	out.puts(".l"); out.putu(loopStart); out.putsln(":");
	out.putsln("    cmp rcx, rdx");
	out.puts("    jnb .l"); out.putu(loopEnd); out.putln(); // exit the loop if i >= length

	// address (offsetted) is already in rax at this point
	generate_method_call(null, stmt.deconstructor.elementType, &deconstructorName, null, out);

	// Set registers as such:
	// rcx - i
	// rax - address (offsetted)
	// rdx - length
	out.putsln("    mov rcx, [rsp]");
	out.putsln("    mov rax, [rsp+16]");
	out.putsln("    mov rdx, [rsp+8]");

	// Increment (and store) i (by 1) and the offsetted address (by the size of an element)
	out.putsln("    add rcx, 1");
	out.putsln("    mov [rsp], rcx");
	out.puts("    add rax, "); out.putu(stmt.deconstructor.elementType.size()); out.putln();
	out.putsln("    mov [rsp+16], rax");

	// complete the loop
	out.puts("    jmp .l"); out.putu(loopStart); out.putln();

	out.puts(".l"); out.putu(loopEnd); out.putsln(":");
	// Set rax to the final result address (which is the same as the one malloc originally returned)
	// then pop the values from the stack
	out.putsln("    mov rax, [rsp+24]");
	out.putsln("    add rsp, 32");
}

function generate_statement(stmt: Node*, out: File*) {
	when(stmt.type) {
		NodeType::IF -> {
			generate_if_statement(stmt, out);
		}
		NodeType::WHILE -> {
			generate_while_statement(stmt, out);
		}
		NodeType::DO_WHILE -> {
			generate_do_while_statement(stmt, out);
		}
		NodeType::FOR -> {
			generate_for_statement(stmt, out);
		}
		NodeType::WHEN -> {
			generate_when_statement(stmt, out);
		}
		NodeType::RETURN -> {
			if(stmt.unary != null)
				generate_expr(stmt.unary, out);
			out.putsln("    leave");
			out.putsln("    ret");
		}
		NodeType::DEFINE_VAR -> {
			generate_define_var(stmt, out);
		}
		NodeType::EXPR_STMT -> {
			generate_expr(stmt.unary, out);
		}
		NodeType::BLOCK -> {
			generate_block(stmt, out);
		}
		NodeType::CONTINUE -> {
			out.puts("    jmp .l"); out.putd(continueLabel); out.putln();
		}
		NodeType::BREAK -> {
			out.puts("    jmp .l"); out.putd(breakLabel); out.putln();
		}
		NodeType::DELETE -> {
			generate_delete(stmt, out);
		}
		NodeType::DELETE_ARRAY -> {
			generate_delete_array(stmt, out);
		}
		else -> {
			eputs("Unsupported type in generate_statement - "); eputs(node_type_to_string(stmt.type)); eputln();
			exit(1);
		}
	}
}

function generate_block(block: Node*, out: File*) {
	for(var i = 0; i < block.block.children.size; ++i) {
		generate_statement(block.block.children.at(i), out);
	}
}

function generate_function(funktion: Node*, out: File*) {
	if(!funktion.funktion.isMethod) {
		out.puts("global _F"); out.put_name(&funktion.funktion.name); out.putln();
		out.puts("_F"); out.put_name(&funktion.funktion.name); out.putsln(":");
	}
	else {
		out.puts("global _M"); out.put_name(&funktion.funktion.parentType.name); 
		out.puts("_"); out.put_name(&funktion.funktion.name); out.putln();

		out.puts("_M"); out.put_name(&funktion.funktion.parentType.name);
		out.puts("_"); out.put_name(&funktion.funktion.name); out.putsln(":");
	}

	out.putsln("    push rbp");
	out.putsln("    mov rbp, rsp");

	var stackDepth = ceil_multiple(funktion.funktion.localVariableStackOffset, 16);
	if(stackDepth != 0) {
		out.puts("    sub rsp, "); out.putd(stackDepth); out.putln();
	}

	var intRegUse = 0;
	var floatRegUse = 0;
	var stackUse = 0;

	for(var i = 0; i < funktion.funktion.arguments.size; ++i) {
		var arg: Node* = funktion.funktion.arguments.at(i);

		if(arg.variable.type.is_float()) {
			if(floatRegUse < FLOAT_ARG_COUNT) {
				out.puts("    movsd [rbp-"); out.putd(arg.variable.stackOffset); out.puts("], "); out.putsln(FLOAT_ARG_REGISTERS[floatRegUse]);
				++floatRegUse;
			}
			else {
				out.puts("    movsd xmm0, [rbp+"); out.putd(8 + (8 * (funktion.funktion.arguments.size - (intRegUse + floatRegUse) - stackUse))); out.putsln("]");
				out.puts("    movsd [rbp-"); out.putd(arg.variable.stackOffset); out.putsln("], xmm0");
				++stackUse;
			}
		}
		else {
			if(intRegUse < INT_ARG_COUNT) {
				out.puts("    mov QWORD [rbp-"); out.putd(arg.variable.stackOffset); out.puts("], "); out.putsln(INT_ARG_REGISTERS[intRegUse]);
				++intRegUse;
			}
			else {
				out.puts("    mov rax, QWORD [rbp+"); out.putd(8 + (8 * (funktion.funktion.arguments.size - (intRegUse + floatRegUse) - stackUse))); out.putsln("]");
				out.puts("    mov QWORD [rbp-"); out.putd(arg.variable.stackOffset); out.putsln("], rax");
				++stackUse;
			}
		}
	}

	generate_block(funktion.funktion.body, out);
}

function Parser.generate_namespace(node: Node*, out: File*) {
	for(var i = 0; i < node.nameSpace.body.block.children.size; ++i) {
		var child: Node* = node.nameSpace.body.block.children.at(i);
		this.generate_top_level_declaration(child, out);
	}
}

function Parser.generate_top_level_declaration(node: Node*, out: File*) {
	when(node.type) {
		NodeType::FUNCTION -> {
			if(node.funktion.used)
				generate_function(node, out);
		}
		NodeType::DEFINE_GLOBAL_VAR -> {
			// Handled below (generate_program)
		}
		NodeType::DEFINE_CONST -> {
			// No code generated - expanded inline
		}
		NodeType::ENUM, NodeType::STRUCT, NodeType::UNION -> {
			// No code generated
		}
		NodeType::NAMESPACE -> {
			this.generate_namespace(node, out);
		}
		else -> {
			eputs("Unsupported type in generate_top_level_declaration - "); eputs(node_type_to_string(node.type)); eputln();
			exit(1);
		}
	}
}

function Parser.generate_string(str: Node*, out: File*) {
	var inQuotes = false;
	var first = true;

	for(var i = 0; str.literal.az.string.chars[i]; ++i) {
		var c = str.literal.az.string.chars[i];

		// Standard ascii range + space, without double quotes
		if(('!' <= c && c <= '~' && c != '\"') || c == ' ') {
			if(!inQuotes) {
				inQuotes = true;
				if(!first) out.puts(", ");
				out.putc('\"');
			}
			out.putc(c);
		}
		else {
			if(inQuotes) {
				inQuotes = false;
				out.putc('\"');
			}
			if(!first) out.puts(", ");
			out.putu(c);
		}
		first = false;
	}

	if(inQuotes) {
		out.putc('\"');
	}

	out.putsln(", 0");
}

function Parser.generate_program(ast: Node*, out: File*) {
	parser = this;
	out.putsln("section .text");
	
	generate_builtin_functions(out);

	for(var i = 0; i < ast.block.children.size; ++i) {
		var node: Node* = ast.block.children.at(i);
		this.generate_top_level_declaration(node, out);
	}

	// Entry point of _start -> initialises state, calls main and exits (via syscall)
	// Uses main's return value as the exit code
	out.putsln("global _start");
	out.putsln("_start:");

	for(var i = 0; i < this.globalVars.size; ++i) {
		var variable: Node* = this.globalVars.at(i);

		if(!variable.variable.used) continue;

		var type = variable.variable.type;

		if(variable.variable.value != null) {
			if(variable.variable.value.type == NodeType::ARRAY_INIT) {
				var array = variable.variable.value;
				var itemType = copy_type(type);
				itemType.indirection = type.indirection - 1;

				for(var i = 0; i < array.block.children.size; ++i) {
					generate_expr(array.block.children.at(i), out);

					if(itemType.is_float()) {
						out.puts("    movsd [_G"); out.put_name(&variable.variable.name); out.puts("+"); out.putd(i * 8);
						out.putsln("], xmm0");
					}
					else {
						out.puts("    mov "); out.puts(type.qualifier()); out.puts(" [_G");
						out.put_name(&variable.variable.name); out.puts("+"); out.putd(i * itemType.size());
						out.puts("], "); out.putsln(type.rax_subregister());
					}
				}
				continue;
			}

			generate_expr(variable.variable.value, out);

			if(type.is_structural()) {
				out.puts("    lea rcx, [_G"); out.put_name(&variable.variable.name); out.putsln("]");
				generate_copy(type.fields, 0, out);
			}
			else {
				out.puts("    mov "); out.puts(type.qualifier()); out.puts(" [_G"); out.put_name(&variable.variable.name);
				out.puts("], "); out.putsln(type.rax_subregister());
			}
		}
	}

	out.putsln("    pop rdi");
	out.putsln("    mov rsi, rsp");

	out.putsln("    call _FZmain");
	out.putsln("    mov rdi, rax");
	out.putsln("    mov rax, 60");
	out.putsln("    syscall");

	if(this.globalVars.size > 0) {
		out.putsln("section .bss");

		for(var i = 0; i < this.globalVars.size; ++i) {
			var variable: Node* = this.globalVars.at(i);

			if(!variable.variable.used) continue;

			out.puts("_G"); out.put_name(&variable.variable.name); out.puts(": ");
			
			var type = variable.variable.type;

			if(type.isArray) {
				var subType = copy_type(type);
				subType.indirection = type.indirection - 1;
				out.puts(subType.reserve()); out.puts(" "); out.putd(type.arrayLength); out.putln();
			}
			else {
				out.puts(variable.variable.type.reserve()); out.putsln(" 1");
			}
		}
	}

	if(this.strings.size > 0 || this.floats.size > 0) {
		out.putsln("section .data");

		for(var i = 0; i < this.strings.size; ++i) {
			var str: Node* = this.strings.at(i);

			if(!str.literal.used) continue;

			out.puts("_S"); out.putd(str.literal.az.string.id); out.puts(": db "); this.generate_string(str, out);
		}

		for(var i = 0; i < this.floats.size; ++i) {
			var float: Node* = this.floats.at(i);

			if(!float.literal.used) continue;

			out.puts("_D"); out.putd(float.literal.az.float.id); out.puts(": dq "); out.putsln(float.literal.az.float.str);
		}
	}
}

}