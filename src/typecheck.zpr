import "std/core.zpr";
import "std/vector.zpr";
import "std/math.zpr";

namespace Typecheck {

var typeStack = new_vector();
var definedTypes = new_vector();
var namespaces = new_vector();

var checkingLoop = false;

function Type.is_integral(): bool {
	return this.indirection == 0 && (
		this.type == DataType::UINT||
		this.type == DataType::U8  ||
		this.type == DataType::U16 ||
		this.type == DataType::U32 ||
		this.type == DataType::U64 ||
		this.type == DataType::INT ||
		this.type == DataType::I8  ||
		this.type == DataType::I16 ||
		this.type == DataType::I32 ||
		this.type == DataType::I64
	);
}

function Type.is_unsigned(): bool {
	return this.indirection == 0 && (
		this.type == DataType::UINT||
		this.type == DataType::U8  ||
		this.type == DataType::U16 ||
		this.type == DataType::U32 ||
		this.type == DataType::U64
	);
}

function Type.is_float(): bool {
	return this.indirection == 0 && this.type == DataType::F64;
}

function Type.is_void(): bool {
	return this.indirection == 0 && this.type == DataType::VOID;
}

function Type.is_structural(): bool {
	resolve_type(this);
	return this.is_structural_base() && this.indirection == 0;
}

function Type.is_structural_base(): bool {
	resolve_type(this);
	return this.type == DataType::STRUCT || this.type == DataType::UNION;
}

function Type.assignable(b: Type*): bool {
	resolve_type(this);
	resolve_type(b);

	if(b.type == DataType::ANY && b.indirection == 0) {
		return true;
	}

	if((this.type == DataType::ANY || b.type == DataType::ANY) && this.indirection >= 1  && b.indirection >= 1) {
		return true;
	}

	if(this.is_integral() && b.is_integral()) {
		return true;
	}

	if(this.type == DataType::STRUCT && b.type == DataType::STRUCT) {
		if(this.indirection != b.indirection) return false;

		if(this.name.equals(&b.name) && this.size() == b.size()) {
			return true;
		}

		return false;
	}

	//TODO Support assigning unions properly

	return this.type == b.type && this.indirection == b.indirection;
}

function Type.size_offset(): int {
	if(this.isArray) {
		var subType = copy_type(this);
		subType.indirection = this.indirection - 1;

		return subType.size() * this.arrayLength;
	}
	return this.size();
}

function Type.size(): int {
	resolve_type(this);
	if(this.indirection != 0) return 8;

	if(this.type == DataType::INT) return 8;
	if(this.type == DataType::I8) return 1;
	if(this.type == DataType::I16) return 2;
	if(this.type == DataType::I32) return 4;
	if(this.type == DataType::I64) return 8;
	if(this.type == DataType::UINT) return 8;
	if(this.type == DataType::U8) return 1;
	if(this.type == DataType::U16) return 2;
	if(this.type == DataType::U32) return 4;
	if(this.type == DataType::U64) return 8;
	if(this.type == DataType::F64) return 8;
	if(this.type == DataType::ANY) return 8;
	if(this.type == DataType::STRUCT) {
		var size = 0;
		var unionSize = 0;
		var inUnion = false;
		for(var i = 0; i < this.fields.size; ++i) {
			var field: Node* = this.fields.at(i);

			// In the case of an anon union,
			// the largest field should account for all fields
			// and the individual fields should not be sized onto the struct
			if(field.variable.unionField) {
				inUnion = true;
				var memSize = field.variable.type.size_offset();
				unionSize = memSize > unionSize ? memSize : unionSize;
			}
			else {
				if(inUnion) {
					inUnion = false;
					size += unionSize;
				}
				size += field.variable.type.size_offset();
			}
		}

		if(inUnion) {
			size += unionSize;
		}

		return size;
	}
	if(this.type == DataType::UNION) {
		var size = 0;
		for(var i = 0; i < this.fields.size; ++i) {
			var memSize = (this.fields.at(i) as Node*).variable.type.size_offset();
			size = memSize > size ? memSize : size;
		}
		return size;
	}

	eputsln("Unreachable - VOID_TYPE.size");
	exit(1);
	return 0;
}

function Node.print_position() {
	this.position.print_position();
}

function Token.print_position() {
	eputs("["); eputs(this.filename); eputs(":"); eputd(this.line); eputs("] Error ");

	if(this.type == TokenType::EOF) {
		eputs("@ EOF");
	}
	else {
		eputs("@ '"); eput_token_string(this); eputs("'");
	}
	eputs(": ");
}

function lookup_type_defined(name: Name*, definedTypes: Vector*, namespaces: Vector*): Type* {
	if(name.namespaceName == null) {
		for(var ni = namespaces.size - 1; ni >= 0; --ni) {
			var nameSpace: Namespace* = namespaces.at(ni);

			for(var i = 0; i < definedTypes.size; ++i) {
				var type: Type* = definedTypes.at(i);

				bind_to_namespace(name, nameSpace);

				if(type.name.equals(name)) {
					return type;
				}
			}
		}
		name.namespaceName = null;
	}
	
	for(var i = 0; i < definedTypes.size; ++i) {
		var type: Type* = definedTypes.at(i);

		if(type.name.equals(name)) {
			return type;
		}
	}

	return null;
}

function lookup_type(name: Name*): Type* {
	var type = lookup_type_defined(name, definedTypes, namespaces);

	if(type != null) return type;

	name.print_position();
	eputs("Unknown type '"); name.eput(); eputsln("'");
	exit(1);

	return null;
}

function resolve_type(type: Type*): Type* {
	if(type.type != DataType::UNRESOLVED) return type;
	var resolve = lookup_type(&type.name);

	if(resolve.type == DataType::ALIAS) {
		var copy = copy_type(resolve.aliased);
		copy.indirection = type.indirection;
		copy.isArray = type.isArray;
		copy.arrayLength = type.arrayLength;
		copy.aliased = resolve;
		*type = *copy;
		return type;
	}

	var copy = copy_type(resolve);
	copy.indirection = type.indirection;
	copy.isArray = type.isArray;
	copy.arrayLength = type.arrayLength;
	*type = *copy;
	return type;
}

function Parser.lookup_variable(name: Name*): Node* {
	var block = this.currentBlock;

	while(block != null) {
		var variable = this.lookup_scope_variable(name, block);
		if(variable != null) return variable;
		block = block.block.parent;
	}

	for(var i = 0; i < this.currentFunction.funktion.arguments.size; ++i) {
		var arg: Node* = this.currentFunction.funktion.arguments.at(i);

		if(arg.variable.name.equals(name)) {
			return arg;
		}
	}

	var constant = this.lookup_constant(name);
	if(constant != null) return constant;

	var global = this.lookup_global_variable(name);
	if(global != null) return global;

	return null;
}

function Parser.lookup_function(name: Name*): Vector* {
	if(name.namespaceName == null) {
		for(var ni = namespaces.size - 1; ni >= 0; --ni) {
			var nameSpace: Namespace* = namespaces.at(ni);

			bind_to_namespace(name, nameSpace);

			var found = false;
			var funcList = this.get_function(name, &found);

			if(found) {
				return funcList;
			}
		}
		name.namespaceName = null;
	}

	var found = false;
	var funcList = this.get_function(name, &found);

	return funcList;
}

function Parser.lookup_function_with_arguments(name: Name*, arguments: Vector*): Node* {
	var list = this.lookup_function(name);
	if(list == null) return null;

	for(var i = 0; i < list.size; ++i) {
		var func: Node* = list.at(i);

		if(func.funktion.arguments.size != arguments.size) continue;

		var match = true;

		for(var arg = 0; arg < arguments.size; ++arg) {
			var defArg: Node* = func.funktion.arguments.at(arg);
			var givenType: Type* = arguments.at(arg);

			if(!givenType.assignable(defArg.variable.type)) {
				match = false;
				break;
			}
		}

		if(match) {
			return func;
		}
	}

	return null;
}

function Parser.count_function_with_arguments(name: Name*, arguments: Vector*): int {
	var list = this.lookup_function(name);
	if(list == null) return 0;

	var count = 0;
	
	for(var i = 0; i < list.size; ++i) {
		var func: Node* = list.at(i);

		if(func.funktion.arguments.size != arguments.size) continue;

		var match = true;

		for(var arg = 0; arg < arguments.size; ++arg) {
			var defArg: Node* = func.funktion.arguments.at(arg);
			var givenType: Type* = arguments.at(arg);

			if(!givenType.assignable(defArg.variable.type)) {
				match = false;
				break;
			}
		}

		if(match) {
			++count;
		}
	}

	return count;
}

function Parser.lookup_constant(name: Name*): Node* {
	if(name.namespaceName == null) {
		for(var ni = namespaces.size - 1; ni >= 0; --ni) {
			var nameSpace: Namespace* = namespaces.at(ni);

			for(var i = 0; i < this.constants.size; ++i) {
				var constant: Node* = this.constants.at(i);

				bind_to_namespace(name, nameSpace);

				if(constant.constant.name.equals(name)) {
					return constant;
				}
			}
		}
		name.namespaceName = null;
	}

	for(var i = 0; i < this.constants.size; ++i) {
		var constant: Node* = this.constants.at(i);
		if(constant.constant.name.equals(name)) {
			return constant;
		}
	}

	return null;
}

function Parser.lookup_scope_variable(name: Name*, block: Node*): Node* {
	for(var i = 0; i < block.block.variables.size; ++i) {
		var variable: Node* = block.block.variables.at(i);

		if(variable.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Parser.lookup_same_scope_variable(name: Name*): Node* {
	return this.lookup_scope_variable(name, this.currentBlock);
}

function Parser.lookup_global_variable(name: Name*): Node* {
	if(name.namespaceName == null) {
		for(var ni = namespaces.size - 1; ni >= 0; --ni) {
			var nameSpace: Namespace* = namespaces.at(ni);

			for(var i = 0; i < this.globalVars.size; ++i) {
				var variable: Node* = this.globalVars.at(i);

				bind_to_namespace(name, nameSpace);

				if(variable.variable.name.equals(name)) {
					return variable;
				}
			}
		}
		name.namespaceName = null;
	}

	for(var i = 0; i < this.globalVars.size; ++i) {
		var variable: Node* = this.globalVars.at(i);

		if(variable.variable.name.equals(name)) {
			return variable;
		}
	}
	return null;
}

function Type.lookup_field(name: Token*): Node* {
	
	for(var i = 0; i < this.fields.size; ++i) {
		var field: Node* = this.fields.at(i);

		if(field.variable.name.name.equals(name)) {
			return field;
		}
	}

	name.print_position();
	eputs("Type "); eputs(type_to_string(this)); eputs(" has no member "); eput_token_string(name); eputln();
	exit(1);

	return null;
}

function Type.lookup_method(name: Name*): Vector* {
	resolve_type(this);

	var found = false;
	var methodList = this.get_method(name, &found);

	return methodList;
}

function Type.lookup_method_with_arguments(name: Name*, arguments: Vector*): Node* {
	var list = this.lookup_method(name);
	if(list == null) return null;

	for(var i = 0; i < list.size; ++i) {
		var method: Node* = list.at(i);

		if(method.funktion.arguments.size - 1 != arguments.size) continue;

		var match = true;

		for(var arg = 1; arg < method.funktion.arguments.size; ++arg) {
			var defArg: Node* = method.funktion.arguments.at(arg);
			var givenType: Type* = arguments.at(arg - 1);

			if(!givenType.assignable(defArg.variable.type)) {
				match = false;
				break;
			}
		}

		if(match) {
			return method;
		}
	}

	return null;
}

function Type.count_method_with_arguments(name: Name*, arguments: Vector*): int {
	var list = this.lookup_method(name);
	if(list == null) return 0;

	var count = 0;

	for(var i = 0; i < list.size; ++i) {
		var method: Node* = list.at(i);

		if(method.funktion.arguments.size - 1 != arguments.size) continue;

		var match = true;

		for(var arg = 1; arg < method.funktion.arguments.size; ++arg) {
			var defArg: Node* = method.funktion.arguments.at(arg);
			var givenType: Type* = arguments.at(arg - 1);

			if(!givenType.assignable(defArg.variable.type)) {
				match = false;
				break;
			}
		}

		if(match) {
			++count;
		}
	}

	return count;
}

function get_name_from_overload(op: Token*): Name* {
	var funcName: i8*;
	when(op.type) {
		TokenType::EQ -> funcName = "copy";
	}

	var nameTok = synthetic_token(TokenType::IDENTIFIER, funcName);
	var name = new Name;
	bind_name(name, nameTok);
	return name;
}

function get_overload_function(lhs: Type*, rhs: Type*, op: Token*): Node* {
	var name = get_name_from_overload(op);

	var args = new_vector();
	args.push(rhs);

	var copy = lhs.lookup_method_with_arguments(name, args);
	return copy;
}

function eput_argument_types(argTypes: Vector*) {
	eputs("(");
	for(var i = 0; i < argTypes.size; ++i) {
		var arg: Type* = argTypes.at(i);
		eputs(uq_type_to_string(arg));
		if(i != argTypes.size - 1) eputs(", ");
	}
	eputs(")");
}

function assignment_op_to_node_type(op: int): int {
	if(op == TokenType::PLUS_EQ) return NodeType::ADD;
	if(op == TokenType::MINUS_EQ) return NodeType::SUB;
	if(op == TokenType::STAR_EQ) return NodeType::MUL;
	if(op == TokenType::SLASH_EQ) return NodeType::DIV;
	if(op == TokenType::PERCENT_EQ) return NodeType::MOD;
	if(op == TokenType::AMP_EQ) return NodeType::BWAND;
	if(op == TokenType::BAR_EQ) return NodeType::BWOR;
	if(op == TokenType::XOR_EQ) return NodeType::XOR;
	if(op == TokenType::LSH_EQ) return NodeType::LSH;
	if(op == TokenType::RSH_EQ) return NodeType::RSH;

	eputsln("Unreachable in assignment_op_to_node_type");
	exit(1);
	return 0;
}

function synthetic_binary_op(op: Token*, lhs: Node*, rhs: Node*): Node* {
	var type = assignment_op_to_node_type(op.type);
	var node = new_node(type, op);
	node.binary.lhs = lhs;
	node.binary.rhs = rhs;
	return node;
}

function Parser.type_check_addrof(expr: Node*) {
	if(!expr.unary.lvalue) {
		expr.print_position();
		eputsln("Expected lvalue as operand for unary '&'");
		exit(1);
	}

	this.type_check_expr(expr.unary);
	var type: Type* = typeStack.pop();

	var addrType = copy_type(type);
	addrType.indirection = addrType.indirection + 1;

	typeStack.push(addrType);
}

function Parser.type_check_deref(expr: Node*) {
	this.type_check_expr(expr.unary);
	var type: Type* = typeStack.pop();
	resolve_type(type);

	if(type.indirection == 0) {
		expr.print_position();
		eputs("Cannot dereference non-pointer type "); eputs(type_to_string(type)); eputln();
		exit(1);
	}

	var derefType = copy_type(type);
	derefType.indirection = derefType.indirection - 1;

	expr.computedType = derefType;
	typeStack.push(derefType);
}

function Parser.type_check_unary(expr: Node*) {
	if(expr.type == NodeType::ADDROF) {
		this.type_check_addrof(expr);
		return;
	}
	else if(expr.type == NodeType::DEREF) {
		this.type_check_deref(expr);
		return;
	}

	this.type_check_expr(expr.unary);

	var type: Type* = typeStack.top();

	expr.computedType = type;

	if(type.is_float() && expr.type == NodeType::NEG) {
		return;
	}

	if(!type.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on type "); eputs(type_to_string(type)); eputln();
		exit(1);
	}
}

function Parser.type_check_binary(expr: Node*) {
	this.type_check_expr(expr.binary.lhs);
	var left: Type* = typeStack.pop();

	this.type_check_expr(expr.binary.rhs);
	var right: Type* = typeStack.pop();

	if((expr.type == NodeType::EQUAL || expr.type == NodeType::NOT_EQUAL) && left.indirection > 0 && right.indirection > 0 && left.assignable(right)) {
		typeStack.push(INT_TYPE);
		expr.computedType = INT_TYPE;
		return;
	}

	if(left.assignable(INT_TYPE) && right.assignable(INT_TYPE)) {
		// Valid
	}
	else if(left.assignable(F64_TYPE) && right.assignable(F64_TYPE) && is_float_arithmetic(expr.type)) {
		// Valid
	}
	else if(left.assignable(F64_TYPE) && right.assignable(F64_TYPE) && is_comparison(expr.type)) {
		expr.computedType = INT_TYPE;
		typeStack.push(INT_TYPE);
		return;
	}
	// With int <-> float, float always takes priority
	else if((left.assignable(F64_TYPE) && right.assignable(INT_TYPE)) || (left.assignable(INT_TYPE) && right.assignable(F64_TYPE))) {
		if(left.assignable(INT_TYPE)) {
			var cast = new_node(NodeType::INT_TO_FLOAT, expr.binary.lhs.position);
			cast.computedType = F64_TYPE;
			cast.unary = expr.binary.lhs;
			expr.binary.lhs = cast;
			left = F64_TYPE;
		}
		// Right is an integer
		else {
			var cast = new_node(NodeType::INT_TO_FLOAT, expr.binary.rhs.position);
			cast.computedType = F64_TYPE;
			cast.unary = expr.binary.rhs;
			expr.binary.rhs = cast;
			right = F64_TYPE;
		}

		if(is_comparison(expr.type)) {
			expr.computedType = INT_TYPE;
			typeStack.push(INT_TYPE);
			return;
		}
	}
	else {
		expr.print_position();
		eputs("Cannot perform operation '"); eputs(node_type_to_string(expr.type)); eputs("' on types "); eputs(type_to_string(left));
		eputs(" and "); eputs(type_to_string(right)); eputln();
		exit(1);
	}

	expr.computedType = left;
	typeStack.push(left);
}

function Parser.type_check_access_var(expr: Node*) {
	var variable = this.lookup_variable(&expr.variable.name);

	if(variable == null) {
		expr.print_position();
		eputs("Unknown variable '"); expr.variable.name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(variable.type == NodeType::DEFINE_VAR) {
		expr.variable.type = variable.variable.type;
		expr.variable.stackOffset = variable.variable.stackOffset;

		var decay = copy_type(expr.variable.type);

		expr.computedType = decay;
		typeStack.push(decay);
	}
	else if(variable.type == NodeType::DEFINE_GLOBAL_VAR) {
		expr.variable.type = variable.variable.type;
		expr.type = NodeType::ACCESS_GLOBAL_VAR;
		expr.lvalue = LValue::GLOBAL;

		expr.computedType = expr.variable.type;
		typeStack.push(expr.variable.type);
	}
	else if(variable.type == NodeType::DEFINE_CONST) {
		var value = variable.constant.value;

		expr.type = NodeType::INT_LITERAL;
		expr.literal.type = INT_TYPE;
		expr.literal.az.integer = value;

		expr.computedType = INT_TYPE;
		typeStack.push(INT_TYPE);
	}
	else {
		expr.print_position();
		eputsln("Can only access variables");
		exit(1);
	}
}

function Parser.type_check_call(expr: Node*) {
	var funcList = this.lookup_function(&expr.funktion.name);

	if(funcList == null) {
		expr.print_position();
		eputs("Unknown function '"); expr.funktion.name.eput(); eputsln("' in current scope");
		exit(1);
	}

	var argTypes = new_vector();
	for(var i = 0; i < expr.funktion.arguments.size; ++i) {
		var arg: Node* = expr.funktion.arguments.at(i);
		this.type_check_expr(arg);

		var argType: Type* = typeStack.pop();
		argTypes.push(argType);
	}

	var func = this.lookup_function_with_arguments(&expr.funktion.name, argTypes);

	if(func == null) {
		expr.print_position();
		eputs("Failed to resolve function '"); expr.funktion.name.eput(); eputsln("'");
		eputs("Given argument types: "); eput_argument_types(argTypes); eputln();
		exit(1);
	}

	var paramTypes = func.funktion.argTypes;
	if(paramTypes == null) {
		paramTypes = new_vector();
		for(var i = 0; i < func.funktion.arguments.size; ++i) {
			var type: Type* = (func.funktion.arguments.at(i) as Node*).variable.type;
			resolve_type(type);
			paramTypes.push(type);
		}
	}

	if(func.funktion.returnType.is_structural()) {
		expr.funktion.argumentStackOffset = this.currentBlock.block.currentStackOffset += func.funktion.returnType.size_offset();

		if(expr.funktion.argumentStackOffset > this.currentFunction.funktion.localVariableStackOffset) {
			this.currentFunction.funktion.localVariableStackOffset = expr.funktion.argumentStackOffset;
		}
	}

	expr.funktion.argTypes = paramTypes;
	expr.computedType = func.funktion.returnType;
	typeStack.push(func.funktion.returnType);
}

function Parser.type_check_method_call(expr: Node*) {
	this.type_check_expr(expr.funktion.parent);

	var parentType: Type* = typeStack.pop();
	resolve_type(parentType);

	var name = expr.funktion.name;

	if(parentType.type == DataType::STRUCT && parentType.indirection == 0) {
		// Valid case
	}
	else if(parentType.type == DataType::STRUCT && parentType.indirection == 1 && !parentType.isArray) {
		var copy = copy_type(parentType);
		copy.indirection = copy.indirection - 1;
		parentType = copy;
	}
	else {
		expr.print_position();
		eputs("Cannot access method on type "); eputs(type_to_string(parentType)); eputln();
		exit(1);
	}

	expr.funktion.parentType = parentType;

	var argTypes = new_vector();
	for(var i = 0; i < expr.funktion.arguments.size; ++i) {
		var arg: Node* = expr.funktion.arguments.at(i);
		this.type_check_expr(arg);

		var argType: Type* = typeStack.pop();
		argTypes.push(argType);
	}

	var funktion = parentType.lookup_method_with_arguments(&name, argTypes);

	if(funktion == null) {
		expr.print_position();
		eputs("Failed to resolve method '"); expr.funktion.name.eput(); eputs("' of type "); eputsln(type_to_string(parentType));
		eputs("Given argument types: "); eput_argument_types(argTypes); eputln();
		exit(1);
	}

	var paramTypes = funktion.funktion.argTypes;
	if(paramTypes == null) {
		paramTypes = new_vector();
		for(var i = 1; i < funktion.funktion.arguments.size; ++i) {
			var type: Type* = (funktion.funktion.arguments.at(i) as Node*).variable.type;
			resolve_type(type);
			paramTypes.push(type);
		}
	}

	if(funktion.funktion.returnType.is_structural()) {
		expr.funktion.argumentStackOffset = this.currentBlock.block.currentStackOffset += funktion.funktion.returnType.size_offset();

		if(expr.funktion.argumentStackOffset > this.currentFunction.funktion.localVariableStackOffset) {
			this.currentFunction.funktion.localVariableStackOffset = expr.funktion.argumentStackOffset;
		}
	}

	expr.funktion.argTypes = paramTypes;

	expr.computedType = funktion.funktion.returnType;
	typeStack.push(funktion.funktion.returnType);
}

function Parser.type_check_ternary_expr(expr: Node*) {
	this.type_check_expr(expr.conditional.condition);
	var condition: Type* = typeStack.pop();

	if(!condition.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot use type "); eputs(type_to_string(condition)); eputsln(" as a condition");
		exit(1);
	}

	this.type_check_expr(expr.conditional.doTrue);
	var doTrue: Type* = typeStack.pop();

	this.type_check_expr(expr.conditional.doFalse);
	var doFalse: Type* = typeStack.pop();

	if(!doTrue.assignable(doFalse)) {
		expr.print_position();
		eputs("Cannot conditionally return differing types "); eputs(type_to_string(doTrue)); eputs(" and "); eputs(type_to_string(doFalse)); eputln();
		exit(1);
	}

	expr.computedType = doTrue;
	typeStack.push(doTrue);
}

function Parser.type_check_access_subscript(expr: Node*) {
	this.type_check_expr(expr.binary.lhs);
	var lhs: Type* = typeStack.pop();

	if(lhs.indirection == 0) {
		expr.print_position();
		eputs("Cannot subscript value type "); eputs(type_to_string(lhs)); eputln();
		exit(1);
	}

	this.type_check_expr(expr.binary.rhs);
	var rhs: Type* = typeStack.pop();

	if(!rhs.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot subscript with index of type "); eputs(type_to_string(rhs)); eputln();
		exit(1);
	}

	var itemType = copy_type(lhs);
	itemType.indirection = itemType.indirection - 1;

	expr.computedType = itemType;

	typeStack.push(itemType);
}

function Parser.type_check_access_member(expr: Node*) {
	this.type_check_expr(expr.member.parent);

	var parentType: Type* = typeStack.pop();
	resolve_type(parentType);

	var name = expr.member.name;
	var field: Node*;

	if(parentType.is_structural_base() && parentType.indirection == 0) {
		field = parentType.lookup_field(name);
	}
	else if(parentType.is_structural_base() && parentType.indirection == 1 && !parentType.isArray) {
		var copy = copy_type(parentType);
		copy.indirection = copy.indirection - 1;
		field = copy.lookup_field(name);
	}
	else {
		expr.print_position();
		eputs("Cannot access member on type "); eputs(type_to_string(parentType)); eputln();
		exit(1);
	}

	expr.member.memberRef = field;
	expr.computedType = field.variable.type;
	typeStack.push(field.variable.type);
}

function Parser.type_check_assign(expr: Node*) {
	this.type_check_expr(expr.assignment.lhs);

	if(expr.assignment.lhs.type == NodeType::INT_LITERAL) {
		expr.print_position();
		eputsln("Cannot re-assign constant values");
		exit(1);
	}

	var lhs: Type* = typeStack.pop();
	resolve_type(lhs);

	if(expr.assignment.op.type != TokenType::EQ) {
		expr.assignment.rhs = synthetic_binary_op(
			expr.assignment.op,
			expr.assignment.lhs,
			expr.assignment.rhs
		);
	}

	this.type_check_expr(expr.assignment.rhs);

	var rhs: Type* = typeStack.pop();
	resolve_type(rhs);

	if(lhs.is_integral() && rhs.is_float()) {
		var cast = new_node(NodeType::FLOAT_TO_INT, expr.assignment.lhs.position);
		cast.computedType = INT_TYPE;
		cast.unary = expr.assignment.rhs;
		expr.assignment.rhs = cast;
	}
	else if(lhs.is_float() && rhs.is_integral()) {
		var cast = new_node(NodeType::INT_TO_FLOAT, expr.assignment.lhs.position);
		cast.computedType = INT_TYPE;
		cast.unary = expr.assignment.rhs;
		expr.assignment.rhs = cast;
	}
	else if(!rhs.assignable(lhs)) {
		expr.print_position();
		eputs("Cannot assign type "); eputs(type_to_string(rhs)); eputs(" to type "); eputs(type_to_string(lhs));
		eputln();
		exit(1);
	}

	if(expr.assignment.op.type == TokenType::EQ) {
		// lhs and rhs are the same structure
		if(lhs.type == DataType::STRUCT && lhs.indirection == 0) {
			var copyTok = synthetic_token(TokenType::IDENTIFIER, "copy");
			var copyName: Name;
			this.bind_name(&copyName, copyTok);

			var args = new_vector();
			var typePtr = copy_type(lhs);
			typePtr.indirection = 1;
			args.push(typePtr);

			var copy = lhs.lookup_method_with_arguments(&copyName, args);

			if(copy != null) {
				var overload = new_node(NodeType::OVERLOAD, expr.position);
				overload.overload.value = expr.assignment.rhs;
				overload.overload.lhsType = lhs;
				overload.overload.rhsType = typePtr;
				overload.overload.op = expr.assignment.op;
				
				expr.assignment.rhs = overload;
			}
		}
	}

	expr.computedType = lhs;

	typeStack.push(lhs);
}

function Parser.type_check_inc_decrement(expr: Node*) {
	if(expr.unary.lvalue == LValue::NONE) {
		expr.print_position();
		eputs("Invalid lvalue for '"); eputs(node_type_to_string(expr.type)); eputsln("' operation");
		exit(1);
	}

	this.type_check_expr(expr.unary);

	var type: Type* = typeStack.pop();
	resolve_type(type);

	expr.computedType = type;

	if(!type.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot perform '"); eputs(node_type_to_string(expr.type)); eputs("' on type "); eputs(type_to_string(type));
		eputln();
		exit(1);
	}

	typeStack.push(type);
}

// Verify that the malloc function exists with the signature malloc(size: uint): any*
function Parser.resolve_malloc_function(): Node* {
	var mallocTok = synthetic_token(TokenType::IDENTIFIER, "malloc");
	var mallocName: Name;
	this.bind_name(&mallocName, mallocTok);

	var arguments = new_vector();
	arguments.push(UINT_TYPE);

	var mallocFunc = this.lookup_function_with_arguments(&mallocName, arguments);

	if(mallocFunc == null) return null;
	if(mallocFunc.funktion.name.namespaceName != null) return null;
	if(mallocFunc.funktion.returnType.type != DataType::ANY || mallocFunc.funktion.returnType.indirection != 1) return null;

	return mallocFunc;
}

function Parser.type_check_new(expr: Node*) {
	resolve_type(expr.constructor.type);

	if(this.resolve_malloc_function() == null) {
		expr.print_position();
		eputsln("Global 'malloc(size: uint)' function is required for 'new'\n => Try including 'std/core.zpr'");
		exit(1);
	}

	// Constructing an object
	if(expr.constructor.type.type == DataType::STRUCT && expr.constructor.type.indirection == 0) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructor = expr.constructor.type.lookup_method(&constructorName);
		// Perform default operation if constructor does not exist and there are no arguments
		if(constructor == null) {
			if(expr.constructor.arguments.size != 0) {
				expr.print_position();
				eputs("Type "); eputs(type_to_string(expr.constructor.type)); eputs(" has no constructor: expected 0 arguments, got "); 
				eputd(expr.constructor.arguments.size); eputln();
				exit(1);
			}
			// Indicate to codegen to not generate a call to the constructor
			expr.constructor.arguments = null;
		}
		else {
			var argTypes = new_vector();
			for(var i = 0; i < expr.constructor.arguments.size; ++i) {
				var arg: Node* = expr.constructor.arguments.at(i);
				this.type_check_expr(arg);

				var argType: Type* = typeStack.pop();
				argTypes.push(argType);
			}

			var constructor = expr.constructor.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructor == null) {
				expr.print_position();
				eputs("Failed to resolve constructor"); eputs(" of type "); eputsln(type_to_string(expr.constructor.type));
				eputs("Given argument types: "); eput_argument_types(argTypes); eputln();
				exit(1);
			}

			var paramTypes = constructor.funktion.argTypes;
			if(paramTypes == null) {
				paramTypes = new_vector();
				for(var i = 1; i < constructor.funktion.arguments.size; ++i) {
					var type: Type* = (constructor.funktion.arguments.at(i) as Node*).variable.type;
					resolve_type(type);
					paramTypes.push(type);
				}
			}

			expr.constructor.argTypes = paramTypes;
			expr.constructor.shouldConstruct = true;
		}
	}

	var ptr = copy_type(expr.constructor.type);
	ptr.indirection++;
	expr.computedType = ptr;
	typeStack.push(ptr);
}

function Parser.type_check_new_array(expr: Node*) {
	resolve_type(expr.constructor.type);

	if(this.resolve_malloc_function() == null) {
		expr.print_position();
		eputsln("Global 'malloc(size: uint)' function is required for 'new'\n => Try including 'std/core.zpr'");
		exit(1);
	}

	if(expr.constructor.type.type == DataType::STRUCT && expr.constructor.type.indirection == 0) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructor = expr.constructor.type.lookup_method(&constructorName);
		// Perform default operation if constructor does not exist
		// (for now, ) creating via an array does not care if a constructor with more arguments is the only option
		if(constructor == null) {
			expr.constructor.shouldConstruct = false;
		}
		else {
			var argTypes = new_vector();
			var constructorMethod = expr.constructor.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructorMethod == null) {
				eputs("Failed to resolve default constructor"); eputs(" of type "); eputsln(type_to_string(expr.constructor.type));
				exit(1);
			}
			expr.constructor.shouldConstruct = true;
		}
	}

	this.type_check_expr(expr.constructor.array.length);
	var length: Type* = typeStack.pop();

	if(!length.assignable(INT_TYPE)) {
		expr.print_position();
		eputs("Cannot create array with index of type "); eputs(type_to_string(length)); eputln();
		exit(1);
	}

	var ptr = copy_type(expr.constructor.type);
	ptr.indirection++;
	expr.computedType = ptr;
	typeStack.push(ptr);
}

function Parser.type_check_expr(expr: Node*) {
	if(is_unary_op(expr.type)) {
		this.type_check_unary(expr);
	}
	else if(is_binary_op(expr.type)) {
		this.type_check_binary(expr);
	}
	else if(expr.type == NodeType::INT_LITERAL) {
		expr.computedType = INT_TYPE;
		typeStack.push(INT_TYPE);
	}
	else if(expr.type == NodeType::UINT_LITERAL) {
		expr.computedType = UINT_TYPE;
		typeStack.push(UINT_TYPE);
	}
	else if(expr.type == NodeType::CHAR_LITERAL) {
		expr.computedType = I8_TYPE;
		typeStack.push(I8_TYPE);
	}
	else if(expr.type == NodeType::FLOAT_LITERAL) {
		expr.computedType = F64_TYPE;
		typeStack.push(F64_TYPE);
	}
	else if(expr.type == NodeType::STRING) {
		expr.computedType = STR_TYPE;
		typeStack.push(STR_TYPE);
	}
	else if(expr.type == NodeType::ACCESS_VAR || expr.type == NodeType::ACCESS_GLOBAL_VAR) {
		this.type_check_access_var(expr);
	}
	else if(expr.type == NodeType::CALL) {
		this.type_check_call(expr);
	}
	else if(expr.type == NodeType::CALL_METHOD) {
		this.type_check_method_call(expr);
	}
	else if(expr.type == NodeType::TERNARY) {
		this.type_check_ternary_expr(expr);
	}
	else if(expr.type == NodeType::SIZEOF) {
		resolve_type(expr.computedType);
		typeStack.push(INT_TYPE);
	}
	else if(expr.type == NodeType::ACCESS_SUBSCRIPT) {
		this.type_check_access_subscript(expr);
	}
	else if(expr.type == NodeType::CAST) {
		// NOTE: All casts are completely allowed at the moment. Whether or not this is good
		//       or requires a warning in some cases is to be decided.
		this.type_check_expr(expr.unary);
		resolve_type(expr.computedType);

		var unaryType: Type* = typeStack.pop();

		if(unaryType.is_integral() && expr.computedType.is_float()) {
			expr.type = NodeType::INT_TO_FLOAT;
		}
		else if(unaryType.is_float() && expr.computedType.is_integral()) {
			expr.type = NodeType::FLOAT_TO_INT;
		}

		typeStack.push(expr.computedType);
	}
	else if(expr.type == NodeType::INT_TO_FLOAT) {
		typeStack.push(F64_TYPE);
	}
	else if(expr.type == NodeType::FLOAT_TO_INT) {
		typeStack.push(expr.computedType);
	}
	else if(expr.type == NodeType::ACCESS_MEMBER) {
		this.type_check_access_member(expr);
	}
	else if(expr.type == NodeType::ASSIGN) {
		this.type_check_assign(expr);
	}
	else if(expr.type == NodeType::PRE_INCREMENT || expr.type == NodeType::POST_INCREMENT || expr.type == NodeType::PRE_DECREMENT || expr.type == NodeType::POST_DECREMENT) {
		this.type_check_inc_decrement(expr);
	}
	else if(expr.type == NodeType::NEW) {
		this.type_check_new(expr);
	}
	else if(expr.type == NodeType::NEW_ARRAY) {
		this.type_check_new_array(expr);
	}
	else {
		eputsln("Unreachable - type_check_expr");
		exit(1);
	}
}

function Parser.type_check_array_init(array: Node*, arrayType: Type*) {
	if(arrayType.arrayLength < array.block.children.size) {
		array.print_position();
		eputs("Cannot initialize array of length '"); eputd(arrayType.arrayLength); eputs("' with '"); eputd(array.block.children.size);
		eputsln("' items");
		exit(1);
	}

	var declItemType = copy_type(arrayType);
	declItemType.indirection = declItemType.indirection - 1;

	for(var i = 0; i < array.block.children.size; ++i) {
		this.type_check_expr(array.block.children.at(i));

		var item: Type* = typeStack.pop();

		if(!item.assignable(declItemType)) {
			(array.block.children.at(i) as Node*).print_position();
			eputs("Cannot initialize array of type "); eputs(type_to_string(declItemType)); eputs(" with item of type ");
			eputs(type_to_string(item)); eputln();
			exit(1);
		}
	}
	typeStack.push(arrayType);
}

function Parser.type_check_define_var(stmt: Node*) {
	var declType = stmt.variable.type;
	resolve_type(declType);

	var name = stmt.variable.name;

	// Check for Redeclaration
	var redeclaration = this.lookup_same_scope_variable(&name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); name.eput(); eputsln("' in current scope");
		exit(1);
	}

	// Verify types with inference
	if(declType.type == DataType::VOID && stmt.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	var valueType: Type* = null;
	if(declType.type == DataType::VOID) {
		this.type_check_expr(stmt.variable.value);
		stmt.variable.type = typeStack.pop();
		declType = stmt.variable.type;
		valueType = declType;
	}

	resolve_type(stmt.variable.type);

	// Calculate offset from rbp
	stmt.variable.stackOffset = this.currentBlock.block.currentStackOffset += declType.size_offset();

	if(stmt.variable.stackOffset > this.currentFunction.funktion.localVariableStackOffset) {
		this.currentFunction.funktion.localVariableStackOffset = stmt.variable.stackOffset;
	}

	// A value was provided
	if(stmt.variable.value != null) {
		if(valueType == null) {
			if(stmt.variable.value.type == NodeType::ARRAY_INIT) {
				this.type_check_array_init(stmt.variable.value, stmt.variable.type);
				valueType = typeStack.pop();
			}
			else {
				this.type_check_expr(stmt.variable.value);
				valueType = typeStack.pop();
			}
		}

		resolve_type(valueType);

		if(declType.is_integral() && valueType.is_float()) {
			var cast = new_node(NodeType::FLOAT_TO_INT, stmt.position);
			cast.computedType = INT_TYPE;
			cast.unary = stmt.variable.value;
			stmt.variable.value = cast;
		}
		else if(declType.is_float() && valueType.is_integral()) {
			var cast = new_node(NodeType::INT_TO_FLOAT, stmt.position);
			cast.computedType = INT_TYPE;
			cast.unary = stmt.variable.value;
			stmt.variable.value = cast;
		}
		else if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type "); eputs(type_to_string(valueType)); eputs(" to variable expecting "); eputs(type_to_string(declType));
			eputln();
			exit(1);
		}

		// valueType and declType refer to the same struct
		if(declType.type == DataType::STRUCT && declType.indirection == 0) {
			var copyTok = synthetic_token(TokenType::IDENTIFIER, "copy");
			var copyName: Name;
			this.bind_name(&copyName, copyTok);

			var args = new_vector();
			var typePtr = copy_type(declType);
			typePtr.indirection = 1;
			args.push(typePtr);

			var copy = declType.lookup_method_with_arguments(&copyName, args);

			if(copy != null) {
				stmt.variable.copyConstructor = true;
			}
		}
	}

	// A constructor was invoked
	if(stmt.variable.arguments != null) {
		if(stmt.variable.type.type != DataType::STRUCT || stmt.variable.type.indirection != 0) {
			stmt.print_position();
			eputs("Cannot construct type "); eputs(type_to_string(stmt.variable.type)); eputsln(" on the stack");
			exit(1);
		}

		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructor = stmt.variable.type.lookup_method(&constructorName);
		// Perform default operation if constructor does not exist and there are no arguments
		if(constructor == null) {
			if(stmt.variable.arguments.size != 0) {
				stmt.print_position();
				eputs("Type "); eputs(type_to_string(stmt.variable.type)); eputs(" has no constructor: expected 0 arguments, got "); 
				eputd(stmt.variable.arguments.size); eputln();
				exit(1);
			}
			// Indicate to codegen to not generate a call to the constructor
			stmt.variable.arguments = null;
		}
		else {
			var argTypes = new_vector();
			for(var i = 0; i < stmt.variable.arguments.size; ++i) {
				var arg: Node* = stmt.variable.arguments.at(i);
				this.type_check_expr(arg);

				var argType: Type* = typeStack.pop();
				argTypes.push(argType);
			}

			var constructor = stmt.variable.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructor == null) {
				stmt.print_position();
				eputs("Failed to resolve constructor"); eputs(" of type "); eputsln(type_to_string(stmt.variable.type));
				eputs("Given argument types: "); eput_argument_types(argTypes); eputln();
				exit(1);
			}

			var paramTypes = constructor.funktion.argTypes;
			if(paramTypes == null) {
				paramTypes = new_vector();
				for(var i = 1; i < constructor.funktion.arguments.size; ++i) {
					var type: Type* = (constructor.funktion.arguments.at(i) as Node*).variable.type;
					resolve_type(type);
					paramTypes.push(type);
				}
			}
			stmt.variable.argTypes = paramTypes;
		}
	}

	// Neither a value nor a constructor was given - attempt to call the default constructor
	if(stmt.variable.value == null && stmt.variable.arguments == null 
	   && stmt.variable.type.type == DataType::STRUCT && stmt.variable.type.indirection == 0) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructors = stmt.variable.type.lookup_method(&constructorName);

		if(constructors != null) {
			stmt.variable.arguments = new_vector();
			
			var argTypes = new_vector();
			var constructor = stmt.variable.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructor == null) {
				stmt.print_position();
				eputs("Could not resolve default constructor of type "); eputsln(type_to_string(stmt.variable.type));
				exit(1);
			}

			stmt.variable.argTypes = argTypes;
		}
	}

	this.currentBlock.block.variables.push(stmt);
}

function Parser.type_check_if_statement(stmt: Node*) {
	this.type_check_expr(stmt.conditional.condition);

	var conditionType: Type* = typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
		exit(1);
	}

	this.type_check_statement(stmt.conditional.doTrue);

	var trueHasReturned = this.currentBlock.block.hasReturned;
	var falseHasReturned = false;

	if(stmt.conditional.doFalse != null) {
		this.type_check_statement(stmt.conditional.doFalse);
		falseHasReturned = this.currentBlock.block.hasReturned;
	}

	this.currentBlock.block.hasReturned = trueHasReturned && falseHasReturned;
}

function Parser.type_check_while_statement(stmt: Node*) {
	var wasCheckingLoop = checkingLoop;
	checkingLoop = true;

	this.type_check_expr(stmt.conditional.condition);

	var conditionType: Type* = typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
		exit(1);
	}

	this.type_check_statement(stmt.conditional.doTrue);

	checkingLoop = wasCheckingLoop;
}

function Parser.type_check_do_while_statement(stmt: Node*) {
	var wasCheckingLoop = checkingLoop;
	checkingLoop = true;

	// If the statement is a block, check it like a block, but including the condition
	// This allows for the condition to reference variables declared in the body
	if(stmt.conditional.doTrue.type == NodeType::BLOCK) {
		var block = stmt.conditional.doTrue;

		block.block.variables = new_vector();
		block.block.currentStackOffset = this.currentBlock.block.currentStackOffset;
		this.currentBlock = block;

		for(var i = 0; i < block.block.children.size; ++i) {
			if(block.block.hasReturned) {
				(block.block.children.at(i) as Node*).print_position();
				eputsln("Unreachable code (all paths return)");
				exit(1);
			}
			this.type_check_statement(block.block.children.at(i));
		}

		this.type_check_expr(stmt.conditional.condition);
		this.currentBlock = block.block.parent;
	}
	else {
		this.type_check_expr(stmt.conditional.condition);
	}


	var conditionType: Type* = typeStack.pop();

	if(!conditionType.assignable(INT_TYPE)) {
		stmt.print_position();
		eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
		exit(1);
	}

	if(stmt.conditional.doTrue.type != NodeType::BLOCK) {
		this.type_check_statement(stmt.conditional.doTrue);
	}

	checkingLoop = wasCheckingLoop;
}

function Parser.type_check_for_statement(stmt: Node*) {
	var wasCheckingLoop = checkingLoop;
	checkingLoop = true;

	if(stmt.loop.initial != null) this.type_check_statement(stmt.loop.initial);
	if(stmt.loop.condition != null) {
		this.type_check_expr(stmt.loop.condition);
		var conditionType: Type* = typeStack.pop();

		if(!conditionType.assignable(INT_TYPE)) {
			stmt.print_position();
			eputs("Expected condition to be type 'int' but got "); eputs(type_to_string(conditionType)); eputln();
			exit(1);
		}
	}
	if(stmt.loop.iteration != null) {
		this.type_check_expr(stmt.loop.iteration);
		typeStack.pop();
	}

	this.type_check_statement(stmt.loop.body);

	checkingLoop = wasCheckingLoop;
}

function Parser.type_check_when_statement(stmt: Node*) {
	this.type_check_expr(stmt.vhen.match);
	var match: Type* = typeStack.pop();
	resolve_type(match);

	if(!match.assignable(INT_TYPE)) {
		stmt.vhen.match.print_position();
		eputsln("Expected when match clause to be type 'int'");
		exit(1);
	}

	var hasReturned = true;
	for(var i = 0; i < stmt.vhen.branches.size; ++i) {
		var branch: Node* = stmt.vhen.branches.at(i);

		// branch.branch.values are guaranteed to be an integer as they are a constant

		this.type_check_statement(branch.branch.body);
		hasReturned = hasReturned && this.currentBlock.block.hasReturned;
	}

	if(stmt.vhen.default != null) {
		this.type_check_statement(stmt.vhen.default);
		hasReturned = hasReturned && this.currentBlock.block.hasReturned;
	}
	else {
		hasReturned = false;
	}

	this.currentBlock.block.hasReturned = hasReturned;
}

// Verify that the free function exists with the signature free(block: any*): void
function Parser.resolve_free_function(): Node* {
	var freeTok = synthetic_token(TokenType::IDENTIFIER, "free");
	var freeName: Name;
	this.bind_name(&freeName, freeTok);

	var arguments = new_vector();
	arguments.push(ANYP_TYPE);

	var freeFunc = this.lookup_function_with_arguments(&freeName, arguments);

	if(freeFunc == null) return null;
	if(freeFunc.funktion.name.namespaceName != null) return null;
	if(freeFunc.funktion.returnType.type != DataType::VOID) return null;

	return freeFunc;
}

function Parser.type_check_delete_statement(stmt: Node*) {
	this.type_check_expr(stmt.deconstructor.value);
	var targetType: Type* = typeStack.pop();
	resolve_type(targetType);

	if(targetType.indirection == 0) {
		stmt.print_position();
		eputs("Cannot delete non-pointer type "); eputsln(type_to_string(targetType));
		exit(1);
	}

	if(this.resolve_free_function() == null) {
		stmt.print_position();
		eputsln("Global 'free(block: any*)' function is required for 'delete'\n => Try including 'std/core.zpr'");
		exit(1);
	}

	if(targetType.type == DataType::STRUCT) {
		var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
		var deconstructorName: Name;
		this.bind_name(&deconstructorName, deconstructorTok);

		var argTypes = new_vector();
		var deconstructors = targetType.lookup_method(&deconstructorName);

		if(deconstructors != null) {
			stmt.deconstructor.shouldDeconstruct = true;

			var argTypes = new_vector();
			var deconstructor = targetType.lookup_method_with_arguments(&deconstructorName, argTypes);
			if(deconstructor == null) {
				stmt.print_position();
				eputs("The deconstructor of type "); eputs(type_to_string(targetType)); eputsln(" must have 0 arguments");
				exit(1);
			}
		}
	}
}

// Verify that the function std::internal::malloc::__get_array_length(ptr: any*, elementSize: uint): uint exists
function Parser.resolve_get_array_length_function(): Node* {
	var funcTok = synthetic_token(TokenType::IDENTIFIER, "__get_array_length");
	var funcName: Name;
	this.bind_name(&funcName, funcTok);

	var nameSpace = new_namespace(null, null);
	nameSpace.parts = new_vector();

	nameSpace.parts.push(synthetic_token(TokenType::IDENTIFIER, "std"));
	nameSpace.parts.push(synthetic_token(TokenType::IDENTIFIER, "internal"));
	nameSpace.parts.push(synthetic_token(TokenType::IDENTIFIER, "malloc"));

	bind_to_namespace(&funcName, nameSpace);

	var arguments = new_vector();
	arguments.push(ANYP_TYPE);
	arguments.push(UINT_TYPE);

	var func = this.lookup_function_with_arguments(&funcName, arguments);

	if(func == null) return null;
	if(func.funktion.returnType.type != DataType::UINT || func.funktion.returnType.indirection != 0) return null;

	return func;
}

function Parser.type_check_delete_array_statement(stmt: Node*) {
	this.type_check_expr(stmt.deconstructor.value);
	var targetType: Type* = typeStack.pop();
	resolve_type(targetType);

	if(targetType.indirection == 0) {
		stmt.print_position();
		eputs("Cannot delete non-pointer type "); eputsln(type_to_string(targetType));
		exit(1);
	}

	if(this.resolve_free_function() == null) {
		stmt.print_position();
		eputsln("Function 'std::internal::malloc::__get_array_length(ptr: any*, elementSize: uint): uint' is required for 'delete[]'\n => Try including 'std/core.zpr'");
		exit(1);
	}

	var elementType = copy_type(targetType);
	--elementType.indirection;
	stmt.deconstructor.elementType = elementType;

	if(elementType.type == DataType::STRUCT) {
		var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
		var deconstructorName: Name;
		this.bind_name(&deconstructorName, deconstructorTok);

		var deconstructors = elementType.lookup_method(&deconstructorName);

		if(deconstructors != null) {
			var argTypes = new_vector();
			var deconstructor = elementType.lookup_method_with_arguments(&deconstructorName, argTypes);

			if(deconstructor == null) {
				stmt.print_position();
				eputs("The deconstructor of type "); eputs(type_to_string(elementType)); eputsln(" must have 0 arguments"); 
				exit(1);
			}
			stmt.deconstructor.shouldDeconstruct = true;
		}
	}
}

function Parser.type_check_return(stmt: Node*) {
	var returnType: Type*;

	if(stmt.ret.value != null) {
		this.type_check_expr(stmt.ret.value);
		returnType = typeStack.pop();
	}
	else {
		returnType = VOID_TYPE;
	}

	var expectedType = this.currentFunction.funktion.returnType;
	if(!returnType.assignable(expectedType)) {
		stmt.print_position();
		eputs("Cannot return type "); eputs(type_to_string(returnType)); eputs(" from function expecting "); eputs(type_to_string(expectedType));
		eputln();
		exit(1);
	}

	if(expectedType.is_structural()) {
		stmt.ret.isStructural = true;
		stmt.ret.structureVarOffset = this.currentFunction.funktion.argumentStackOffset;
	}

	stmt.ret.type = expectedType;

	if(this.currentBlock.block.variables.size > 0) {
		stmt.ret.variables = new_vector();
		
		var block = this.currentBlock;

		while(block != null) {
			for(var i = block.block.variables.size - 1; i >= 0; --i) {
				var variable: Node* = block.block.variables.at(i);

				if(variable.variable.type.type != DataType::STRUCT || variable.variable.type.indirection != 0) {
					continue;
				}

				var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
				var deconstructorName: Name;
				this.bind_name(&deconstructorName, deconstructorTok);

				var deconstructors = variable.variable.type.lookup_method(&deconstructorName);

				if(deconstructors != null) {
					var argTypes = new_vector();
					var deconstructor = variable.variable.type.lookup_method_with_arguments(&deconstructorName, argTypes);

					if(deconstructor == null) {
						variable.print_position();
						eputs("The deconstructor of type "); eputs(type_to_string(variable.variable.type)); eputsln(" must have 0 arguments"); 
						exit(1);
					}
					stmt.ret.variables.push(variable);
				}
			}

			block = block.block.parent;
		}
	}

	this.currentBlock.block.hasReturned = true;
}

function Parser.type_check_statement(stmt: Node*) {
	if(stmt.type == NodeType::IF) {
		this.type_check_if_statement(stmt);
	}
	else if(stmt.type == NodeType::WHILE) {
		this.type_check_while_statement(stmt);
	}
	else if(stmt.type == NodeType::DO_WHILE) {
		this.type_check_do_while_statement(stmt);
	}
	else if(stmt.type == NodeType::FOR) {
		this.type_check_for_statement(stmt);
	}
	else if(stmt.type == NodeType::WHEN) {
		this.type_check_when_statement(stmt);
	}
	else if(stmt.type == NodeType::RETURN) {
		this.type_check_return(stmt);
	}
	else if(stmt.type == NodeType::DEFINE_VAR) {
		this.type_check_define_var(stmt);
	}
	else if(stmt.type == NodeType::EXPR_STMT) {
		this.type_check_expr(stmt.unary);
	}
	else if(stmt.type == NodeType::BLOCK) {
		this.type_check_block(stmt);
		this.currentBlock.block.hasReturned = stmt.block.hasReturned;
	}
	else if(stmt.type == NodeType::CONTINUE) {
		if(!checkingLoop) {
			stmt.print_position();
			eputsln("Cannot use 'continue' outside of a loop");
			exit(1);
		}
	}
	else if(stmt.type == NodeType::BREAK) {
		if(!checkingLoop) {
			stmt.print_position();
			eputsln("Cannot use 'break' outside of a loop");
			exit(1);
		}
	}
	else if(stmt.type == NodeType::DELETE) {
		this.type_check_delete_statement(stmt);
	}
	else if(stmt.type == NodeType::DELETE_ARRAY) {
		this.type_check_delete_array_statement(stmt);
	}
	else {
		eputsln("Unreachable - type_check_statement");
		exit(1);
	}
}

function Parser.type_check_block(block: Node*) {
	block.block.variables = new_vector();
	block.block.currentStackOffset = this.currentBlock.block.currentStackOffset;
	this.currentBlock = block;

	for(var i = 0; i < block.block.children.size; ++i) {
		if(block.block.hasReturned) {
			(block.block.children.at(i) as Node*).print_position();
			eputsln("Unreachable code (all paths return)");
			exit(1);
		}
		this.type_check_statement(block.block.children.at(i));
	}

	for(var i = 0; i < block.block.variables.size; ++i) {
		var stmt: Node* = block.block.variables.at(i);

		if(stmt.variable.type.type != DataType::STRUCT || stmt.variable.type.indirection != 0) {
			continue;
		}

		var deconstructorTok = synthetic_token(TokenType::IDENTIFIER, "deconstructor");
		var deconstructorName: Name;
		this.bind_name(&deconstructorName, deconstructorTok);

		var deconstructors = stmt.variable.type.lookup_method(&deconstructorName);

		if(deconstructors != null) {
			var argTypes = new_vector();
			var deconstructor = stmt.variable.type.lookup_method_with_arguments(&deconstructorName, argTypes);

			if(deconstructor == null) {
				stmt.print_position();
				eputs("The deconstructor of type "); eputs(type_to_string(stmt.variable.type)); eputsln(" must have 0 arguments"); 
				exit(1);
			}
			stmt.deconstructor.shouldDeconstruct = true;
		}
	}

	this.currentBlock = block.block.parent;
}

function Parser.type_check_function(funktion: Node*) {
	var stackOffset = 0;

	if(!funktion.funktion.isMethod) {
		var funcList = this.lookup_function(&funktion.funktion.name);

		var paramTypes = new_vector();
		for(var i = 0; i < funktion.funktion.arguments.size; ++i) {
			var arg: Node* = funktion.funktion.arguments.at(i);

			paramTypes.push(arg.variable.type);
		}

		funktion.funktion.argTypes = paramTypes;

		if(funcList.size != 1) {
			var count = this.count_function_with_arguments(&funktion.funktion.name, paramTypes);

			if(count != 1) {
				funktion.print_position();
				eputsln("Redeclaration of function accepting same arguments");
				exit(1);
			}
		}
	}
	else {
		var methodList = funktion.funktion.parentType.lookup_method(&funktion.funktion.name);

		var paramTypes = new_vector();
		for(var i = 1; i < funktion.funktion.arguments.size; ++i) {
			var arg: Node* = funktion.funktion.arguments.at(i);

			paramTypes.push(arg.variable.type);
		}

		funktion.funktion.argTypes = paramTypes;

		if(methodList.size != 1) {
			var count = funktion.funktion.parentType.count_method_with_arguments(&funktion.funktion.name, paramTypes);

			if(count != 1) {
				funktion.print_position();
				eputsln("Redeclaration of method accepting same arguments");
				exit(1);
			}
		}
	}

	for(var i = 0; i < funktion.funktion.arguments.size; ++i) {
		var arg: Node* = funktion.funktion.arguments.at(i);

		resolve_type(arg.variable.type);

		if(arg.variable.type.isArray) {
			arg.print_position();
			eputsln("Arrays cannot be used as function arguments - consider using a pointer instead");
			exit(1);
		}

		if(arg.variable.type.type == DataType::STRUCT && arg.variable.type.indirection == 0) {
			var copyTok = synthetic_token(TokenType::IDENTIFIER, "copy");
			var copyName: Name;
			this.bind_name(&copyName, copyTok);

			var args = new_vector();
			var typePtr = copy_type(arg.variable.type);
			typePtr.indirection = 1;
			args.push(typePtr);

			var copy = arg.variable.type.lookup_method_with_arguments(&copyName, args);

			if(copy != null) {
				arg.variable.copyConstructor = true;
			}
		}

		//FIXME Have the correct qualifiers and registers used in codegen.zpr for arguments
		stackOffset += ceil_multiple(arg.variable.type.size(), 8);

		arg.variable.stackOffset = stackOffset;
	}

	if(funktion.funktion.returnType.isArray) {
		funktion.print_position();
		eputsln("Arrays cannot be used as function return types - consider using a pointer instead");
		exit(1);
	}
	else if(funktion.funktion.returnType.is_structural()) {
		// Space for an implicit pointer
		stackOffset += 8;
	}

	funktion.funktion.argumentStackOffset = stackOffset;
	funktion.funktion.body.block.currentStackOffset = stackOffset;
	funktion.funktion.localVariableStackOffset = stackOffset;

	this.currentFunction = funktion;

	this.currentBlock = funktion.funktion.body;
	this.type_check_block(funktion.funktion.body);

	if(!funktion.funktion.body.block.hasReturned) {
		if(funktion.funktion.returnType.is_void()) {
			var tok = synthetic_token(TokenType::RETURN, "return");
			var implReturn = new_node(NodeType::RETURN, tok);

			this.currentBlock = funktion.funktion.body;
			this.type_check_return(implReturn);
			this.currentBlock = funktion.funktion.body.block.parent;

			funktion.funktion.body.add_child(implReturn);
		}
		else {
			funktion.print_position();
			eputs("A non-void returning function must return a value (returning "); eputs(type_to_string(funktion.funktion.returnType));
			eputsln(")");
			exit(1);
		}
	}
}

function Parser.type_check_global_var(stmt: Node*) {
	var declType = stmt.variable.type;
	resolve_type(declType);
	var name = stmt.variable.name;

	var redeclaration = this.lookup_global_variable(&name);

	if(redeclaration != null) {
		stmt.print_position();
		eputs("Redeclaration of variable '"); name.eput(); eputsln("' in current scope");
		exit(1);
	}

	if(declType.type == DataType::VOID && stmt.variable.value == null) {
		stmt.print_position();
		eputsln("Cannot infer type to variable without initial value");
		exit(1);
	}

	if(declType.type == DataType::VOID) {
		this.type_check_expr(stmt.variable.value);
		stmt.variable.type = typeStack.pop();
		declType = stmt.variable.type;
	}

	resolve_type(stmt.variable.type);

	if(stmt.variable.value != null) {
		if(stmt.variable.value.type == NodeType::ARRAY_INIT) {
			this.type_check_array_init(stmt.variable.value, stmt.variable.type);
		}
		else {
			this.type_check_expr(stmt.variable.value);
		}

		var valueType: Type* = typeStack.pop();
		resolve_type(valueType);

		if(declType.is_integral() && valueType.is_float()) {
			var cast = new_node(NodeType::FLOAT_TO_INT, stmt.position);
			cast.computedType = INT_TYPE;
			cast.unary = stmt.variable.value;
			stmt.variable.value = cast;
		}
		else if(declType.is_float() && valueType.is_integral()) {
			var cast = new_node(NodeType::INT_TO_FLOAT, stmt.position);
			cast.computedType = INT_TYPE;
			cast.unary = stmt.variable.value;
			stmt.variable.value = cast;
		}
		else if(!valueType.assignable(declType)) {
			stmt.print_position();
			eputs("Cannot assign type "); eputs(type_to_string(valueType)); eputs(" to variable expecting "); eputs(type_to_string(declType));
			eputln();
			exit(1);
		}

		// valueType and declType refer to the same struct
		if(declType.type == DataType::STRUCT && declType.indirection == 0) {
			var copyTok = synthetic_token(TokenType::IDENTIFIER, "copy");
			var copyName: Name;
			this.bind_name(&copyName, copyTok);

			var args = new_vector();
			var typePtr = copy_type(declType);
			typePtr.indirection = 1;
			args.push(typePtr);

			var copy = declType.lookup_method_with_arguments(&copyName, args);

			if(copy != null) {
				stmt.variable.copyConstructor = true;
			}
		}
	}

	// A constructor was invoked
	if(stmt.variable.arguments != null) {
		if(stmt.variable.type.type != DataType::STRUCT || stmt.variable.type.indirection != 0) {
			stmt.print_position();
			eputs("Cannot construct type "); eputs(type_to_string(stmt.variable.type)); eputsln(" as a global");
			exit(1);
		}

		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructor = stmt.variable.type.lookup_method(&constructorName);
		// Perform default operation if constructor does not exist and there are no arguments
		if(constructor == null) {
			if(stmt.variable.arguments.size != 0) {
				stmt.print_position();
				eputs("Type "); eputs(type_to_string(stmt.variable.type)); eputs(" has no constructor: expected 0 arguments, got "); 
				eputd(stmt.variable.arguments.size); eputln();
				exit(1);
			}
			// Indicate to codegen to not generate a call to the constructor
			stmt.variable.arguments = null;
		}
		else {
			var argTypes = new_vector();
			for(var i = 0; i < stmt.variable.arguments.size; ++i) {
				var arg: Node* = stmt.variable.arguments.at(i);
				this.type_check_expr(arg);

				var argType: Type* = typeStack.pop();
				argTypes.push(argType);
			}

			var constructor = stmt.variable.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructor == null) {
				stmt.print_position();
				eputs("Failed to resolve constructor"); eputs(" of type "); eputsln(type_to_string(stmt.variable.type));
				eputs("Given argument types: "); eput_argument_types(argTypes); eputln();
				exit(1);
			}

			var paramTypes = constructor.funktion.argTypes;
			if(paramTypes == null) {
				paramTypes = new_vector();
				for(var i = 1; i < constructor.funktion.arguments.size; ++i) {
					var type: Type* = (constructor.funktion.arguments.at(i) as Node*).variable.type;
					resolve_type(type);
					paramTypes.push(type);
				}
			}
			stmt.variable.argTypes = paramTypes;
		}
	}

	// Neither a value nor a constructor was given - attempt to call the default constructor
	if(stmt.variable.value == null && stmt.variable.arguments == null 
	   && stmt.variable.type.type == DataType::STRUCT && stmt.variable.type.indirection == 0) {
		var constructorTok = synthetic_token(TokenType::IDENTIFIER, "constructor");
		var constructorName: Name;
		this.bind_name(&constructorName, constructorTok);

		var constructors = stmt.variable.type.lookup_method(&constructorName);

		if(constructors != null) {
			stmt.variable.arguments = new_vector();
			
			var argTypes = new_vector();
			var constructor = stmt.variable.type.lookup_method_with_arguments(&constructorName, argTypes);

			if(constructor == null) {
				stmt.print_position();
				eputs("Could not resolve default constructor of type "); eputsln(type_to_string(stmt.variable.type));
				exit(1);
			}

			stmt.variable.argTypes = argTypes;
		}
	}

	this.globalVars.push(stmt);
}

function add_offsets_to_union(unionType: Type*) {
	if(unionType.built) return;
	unionType.built = true;

	for(var i = 0; i < unionType.fields.size; ++i) {
		var field: Node* = unionType.fields.at(i);
		var type = field.variable.type;

		if((type.type == DataType::UNRESOLVED || type.type == DataType::UNION) && type.name.equals(&unionType.name) && type.indirection == 0) {
			field.print_position();
			eputsln("A union cannot contain a member of itself (use a pointer instead)");
			exit(1);
		}

		field.variable.stackOffset = 0;

		resolve_type(type);
		resolve_type(field.variable.type);

		if(type.type == DataType::STRUCT) {
			add_offsets_to_struct(type);
		}
		else if(type.type == DataType::UNION) {
			add_offsets_to_union(type);
		}
	}
}

function add_offsets_to_struct(structType: Type*) {
	if(structType.built) return;
	structType.built = true;

	var offset = 0;

	for(var i = 0; i < structType.fields.size; ++i) {
		var field: Node* = structType.fields.at(i);
		var type = field.variable.type;

		if((type.type == DataType::UNRESOLVED || type.type == DataType::STRUCT) && type.name.equals(&structType.name) && type.indirection == 0) {
			field.print_position();
			eputsln("A struct cannot contain a member of itself (use a pointer instead)");
			exit(1);
		}

		resolve_type(type);
		resolve_type(field.variable.type);
		
		field.variable.stackOffset = offset;

		if(!field.variable.unionField)
			offset += field.variable.type.size_offset();

		if(type.type == DataType::STRUCT) {
			add_offsets_to_struct(type);
		}
		else if(type.type == DataType::UNION) {
			add_offsets_to_union(type);
		}
	}
}

function Parser.type_check_namespace(nameSpace: Node*) {
	namespaces.push(nameSpace.nameSpace.name);

	for(var i = 0; i < nameSpace.nameSpace.body.block.children.size; ++i) {
		var node: Node* = nameSpace.nameSpace.body.block.children.at(i);

		this.type_check_top_level_declaration(node);
	}

	namespaces.pop();
}

function Parser.type_check_top_level_declaration(node: Node*) {
	var mainTok = synthetic_token(TokenType::IDENTIFIER, "main");
	var mainName: Name;
	this.bind_name(&mainName, mainTok);

	if(node.type == NodeType::FUNCTION) {
		if(!node.funktion.hasImplicitBody)
			this.type_check_function(node);
	}
	else if(node.type == NodeType::DEFINE_GLOBAL_VAR) {
		this.type_check_global_var(node);
	}
	else if(node.type == NodeType::DEFINE_CONST) {
		if(this.lookup_global_variable(&node.constant.name) != null) {
			node.print_position();
			eputs("Redeclaration of constant '"); node.constant.name.eput(); eputsln("'");
			exit(1);
		}
		// Do nothing - parser verifies that this is an integer
	}
	else if(node.type == NodeType::ENUM) {
		// Do nothing - parser verifies that all fields are integers
	}
	else if(node.type == NodeType::STRUCT) {
		add_offsets_to_struct(node.computedType);
	}
	else if(node.type == NodeType::UNION) {
		add_offsets_to_union(node.computedType);
	}
	else if(node.type == NodeType::NAMESPACE) {
		this.type_check_namespace(node);
	}
	else {
		eputsln("Unreachable - unhandled node type in type_check_top_level_declaration");
		exit(1);
	}
}

function Parser.type_check(program: Node*) {
	definedTypes = this.definedTypes;
	namespaces = new_vector();

	for(var i = 0; i < program.block.children.size; ++i) {
		var node: Node* = program.block.children.at(i);

		this.type_check_top_level_declaration(node);
	}
}

}