import "std/core.zpr";
import "std/map.zpr";
import "src/types.zpr";
import "src/lexer.zpr";
import "src/ast.zpr";
import "src/builtin.zpr";

struct Parser {
	lexer: Lexer*;
	current: Token*;
	previous: Token*;

	currentFunction: Node*;
	currentBlock: Node*;

	functions: std::map::HashMap*;

	globalVars: Vector*;

	strings: Vector*;
	floats: Vector*;

	definedTypes: Vector*;

	lexerStack: Vector*;

	openedFiles: Vector*;

	constants: Vector*;

	namespaceStack: Vector*;

	error: int;
	panic: int;
}

function new_parser(lexer: Lexer*): Parser* {
	var parser = new Parser;
	parser.lexer = lexer;
	parser.functions = new std::map::HashMap();
	parser.globalVars = new Vector();
	parser.strings = new Vector();
	parser.floats = new Vector();
	parser.definedTypes = new Vector();
	parser.lexerStack = new Vector();
	parser.openedFiles =  new Vector();
	parser.constants = new Vector();
	parser.namespaceStack = new Vector();
	return parser;
}

function new_node(type: int, position: Token*): Node* {
	var node: Node* = new Node;
	node.type = type;
	node.position = position;
	return node;
}

function Node.add_child(child: Node*) {
	this.block.children.push(child);
}

function Parser.namespace_name(name: Name*, token: Token*) {
	name.name = token;
	if(!this.namespaceStack.empty()) {
		name.namespaceName = this.namespaceStack.top();
	}
}

function Parser.bind_name(name: Name*, token: Token*) {
	name.name = token;
	name.namespaceName = null;
}

function Parser.bind_namespace(name: Name*) {
	if(!this.namespaceStack.empty()) {
		name.namespaceName = this.namespaceStack.top();
	}
}

function bind_to_namespace(name: Name*, namespaceName: Namespace*) {
	name.namespaceName = namespaceName;
}

function Parser.add_function(funktion: Node*) {
	var nameStr = funktion.funktion.name.to_string();

	var found = false;
	var list = this.functions.get(nameStr, &found) as Vector*;

	if(found) {
		list.push(funktion);
	}
	else {
		list = new Vector();
		list.push(funktion);
		this.functions.set(nameStr, list);
	}
}

function Parser.get_function(name: Name*, found: bool*): Vector* {
	var nameStr = name.to_string();

	var list = this.functions.get(nameStr, found) as Vector*;

	return list;
}

function allow_expr_stmt(expr: Node*): int {
	return expr.type == NodeType::CALL ||
	       expr.type == NodeType::CALL_METHOD ||
		   expr.type == NodeType::ASSIGN ||
		   expr.type == NodeType::PRE_INCREMENT ||
		   expr.type == NodeType::PRE_DECREMENT ||
		   expr.type == NodeType::POST_INCREMENT ||
		   expr.type == NodeType::POST_DECREMENT;
}

function is_assignment(type: int): int {
	return type == TokenType::EQ ||
	       type == TokenType::PLUS_EQ ||
	       type == TokenType::MINUS_EQ ||
	       type == TokenType::STAR_EQ ||
	       type == TokenType::SLASH_EQ ||
	       type == TokenType::PERCENT_EQ ||
	       type == TokenType::AMP_EQ ||
	       type == TokenType::BAR_EQ ||
	       type == TokenType::XOR_EQ ||
		   type == TokenType::LSH_EQ ||
		   type == TokenType::RSH_EQ;
}

function Parser.lookup_type(name: Name*): Type* {
	var type = Typecheck::lookup_type_defined(name, this.definedTypes, this.namespaceStack);

	if(type != null) return type;

	this.error("Unknown Type");

	return null;
}

function Parser.error_at_token(token: Token*, message: i8*) {
	if(this.panic) return;
	this.panic = true;
	eputs("["); eputs(token.filename); eputs(":"); eputd(token.line); eputs("] Error");

	if(token.type == TokenType::EOF) {
		eputs(" @ EOF");
	}
	else if(token.type == TokenType::ERROR) {
		// No value to print
	}
	else {
		eputs(" @ '"); eput_token_string(token); eputs("'");
	}

	eputs(": "); eputsln(message);

	this.error = true;
	
	exit(1);
}

function Parser.error(message: i8*) {
	this.error_at_token(this.previous, message);
}

function Parser.error_current(message: i8*) {
	this.error_at_token(this.current, message);
}

function Parser.advance() {
	this.previous = this.current;

	for(;;) {
		this.current = this.lexer.next();
		if(this.current.type != TokenType::ERROR) break;

		this.error_current(this.current.start);
	}
}

function Parser.consume(type: int, message: i8*): Token* {
	if(this.current.type == type) {
		this.advance();
		return this.previous;
	}

	this.error_current(message);
	return this.current;
}

function Parser.check(type: int): int {
	return this.current.type == type;
}

function Parser.match(type: int): int {
	if(!this.check(type)) return false;
	this.advance();
	return true;
}

function Parser.peek(): Token* {
	var start = this.lexer.start;
	var current = start;
	var line = this.lexer.line;
	var tok = this.lexer.next();
	this.lexer.start = start;
	this.lexer.current = current;
	this.lexer.line = line;
	return tok;
}

function Parser.find_string(needle: Node*): Node* {
	var length = needle.literal.az.string.length;
	var chars = needle.literal.az.string.chars;

	for(var i = 0; i < this.strings.size; ++i) {
		var str: Node* = this.strings.at(i);

		if(str.literal.az.string.length == length && streq(str.literal.az.string.chars, chars)) {
			return str;
		}
	}

	return null;
}

function Parser.parse_type_no_array(): Type* {
	this.advance();

	var type = new Type;

	when(this.previous.type) {
		TokenType::INT -> type.type = DataType::INT;
		TokenType::I8 -> type.type = DataType::I8;
		TokenType::I16 -> type.type = DataType::I16;
		TokenType::I32 -> type.type = DataType::I32;
		TokenType::I64 -> type.type = DataType::I64;
		TokenType::UINT -> type.type = DataType::UINT;
		TokenType::U8 -> type.type = DataType::U8;
		TokenType::U16 -> type.type = DataType::U16;
		TokenType::U32 -> type.type = DataType::U32;
		TokenType::U64 -> type.type = DataType::U64;
		TokenType::F64 -> type.type = DataType::F64;
		TokenType::ANY -> type.type = DataType::ANY;

		TokenType::IDENTIFIER -> {
			type.type = DataType::UNRESOLVED;

			var name = this.previous;

			var nameSpace = new_namespace(null, null);
			nameSpace.parts = new Vector();

			while(this.match(TokenType::COLON_COLON)) {
				nameSpace.parts.push(name);
				name = this.consume(TokenType::IDENTIFIER, "Expected identifier");	
			}

			this.bind_name(&type.name, name);
			if(nameSpace.parts.size > 0) bind_to_namespace(&type.name, nameSpace);
		}
		else -> {
			this.error("Expected type");
		}
	}

	while(this.match(TokenType::STAR)) {
		type.indirection = type.indirection + 1;
	}
	return type;
}

function Parser.parse_type(): Type* {
	var type = this.parse_type_no_array();

	if(this.match(TokenType::LEFT_SQBR)) {
		type.isArray = true;
		type.arrayLength = this.parse_constant();
		type.indirection = type.indirection + 1;
		this.consume(TokenType::RIGHT_SQBR, "Expected ']' after array length");
	}

	return type;
}

function Parser.escape_literal(literal: Token*, index: int): int {
	when(literal.start[index]) {
		'0' -> return '\0';
		'n' -> return '\n';
		'r' -> return '\r';
		't' -> return '\t';
		'v' -> return '\v';
		'\\' -> return '\\';
		'\'' -> return '\'';
		'\"' -> return '\"';

		'x', 'X' -> {
			if(!is_hex_digit(literal.start[index + 1]) || !is_hex_digit(literal.start[index + 2])) {
				this.error_at_token(literal, "Invalid hexadecimal escape");
			}
			return hex_numeral(literal.start[index + 1])*16 + hex_numeral(literal.start[index + 2]);
		}
	}

	return -1;
}

function Parser.escape_character(literal: Token*): i8 {
	if(literal.start[1] != '\\') {
		return literal.start[1];
	}
	
	var value = this.escape_literal(literal, 2);

	if(value != -1) return value;

	this.error_at_token(literal, "Invalid escape sequence");
	return 0;
}

function Parser.escape_string(literal: Token*, buf: i8*) {
	var bufIdx = 0;
	for(var i = 0; i < literal.length - 2; ++i) {
		var char = literal.start[i + 1];

		if(char != '\\') {
			buf[bufIdx] = char;
			++bufIdx;
			continue;
		}
		
		buf[bufIdx] = this.escape_literal(literal, i + 2);
		if(literal.start[i + 2] == 'x' || literal.start[i + 2] == 'X') i += 2;
		++i;
		++bufIdx;
	}
	buf[bufIdx] = '\0';
}

function Parser.eval_constexpr(expr: Node*): int {
	when(expr.type) {
		// Note: only signed integers are supported as constants, so uint becomes int
		NodeType::INT_LITERAL, NodeType::CHAR_LITERAL, NodeType::UINT_LITERAL -> return expr.literal.az.integer;
		NodeType::ACCESS_VAR -> {
			var constant = this.lookup_constant(&expr.variable.name);
			if(constant == null) {
				this.error("Unknown compile-time constant");
				return 0;
			}
			return constant.constant.value;
		}
	}

	if(is_binary_op(expr.type)) {
		var left = this.eval_constexpr(expr.binary.lhs);
		var right = this.eval_constexpr(expr.binary.rhs);

		when(expr.type) {
			NodeType::ADD -> return left + right;
			NodeType::SUB -> return left - right;
			NodeType::MUL -> return left * right;
			NodeType::DIV -> return left / right;
			NodeType::MOD -> return left % right;
			NodeType::BWAND -> return left & right;
			NodeType::BWOR -> return left | right;
			NodeType::XOR -> return left ^ right;
			NodeType::LSH -> return left << right;
			NodeType::RSH -> return left >> right;
			NodeType::EQUAL -> return left == right;
			NodeType::NOT_EQUAL -> return left != right;
			NodeType::LESS -> return left < right;
			NodeType::LESS_EQ -> return left <= right;
			NodeType::GREATER -> return left > right;
			NodeType::GREATER_EQ -> return left >= right;
			NodeType::OR -> return left || right;
			NodeType::AND -> return left && right;
		}
	}

	if(expr.type == NodeType::TERNARY) {
		var condition = this.eval_constexpr(expr.conditional.condition);
		var doTrue = this.eval_constexpr(expr.conditional.doTrue);
		var doFalse = this.eval_constexpr(expr.conditional.doFalse);

		return condition ? doTrue : doFalse;
	}

	if(expr.type == NodeType::BWNOT) return ~this.eval_constexpr(expr.unary);
	if(expr.type == NodeType::NOT) return !this.eval_constexpr(expr.unary);
	if(expr.type == NodeType::NEG) return -this.eval_constexpr(expr.unary);

	this.error_at_token(expr.position, "Invalid constant expression");
	return 0;
}

function Parser.parse_constant(): int {
	var expr = this.parse_expression();

	return this.eval_constexpr(expr);
}

function Parser.parse_call(name: Token*): Node* {
	var call = new_node(NodeType::CALL, name);
	this.bind_name(&call.funktion.name, name);
	call.funktion.arguments = new Vector();

	if(!this.check(TokenType::RIGHT_PAREN)) {
		var arg = this.parse_expression();

		call.funktion.arguments.push(arg);

		while(this.match(TokenType::COMMA)) {
			var arg = this.parse_expression();

			call.funktion.arguments.push(arg);
		}
	}

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after function arguments");

	return call;
}

function Parser.parse_identifier(): Node* {
	var name = this.previous;

	var nameSpace = new_namespace(null, null);
	nameSpace.parts = new Vector();

	while(this.match(TokenType::COLON_COLON)) {
		nameSpace.parts.push(name);
		name = this.consume(TokenType::IDENTIFIER, "Expected identifier");
	}

	if(this.match(TokenType::LEFT_PAREN)) {
		var call = this.parse_call(name);
		if(nameSpace.parts.size > 0) bind_to_namespace(&call.funktion.name, nameSpace);
		return call;
	}

	var access = new_node(NodeType::ACCESS_VAR, name);
	this.bind_name(&access.variable.name, name);
	if(nameSpace.parts.size > 0) bind_to_namespace(&access.variable.name, nameSpace);
	access.lvalue = LValue::LOCAL;
	return access;
}

function Parser.parse_new(): Node* {
	var keyword = this.previous;
	var type = this.parse_type_no_array();

	var node = new_node(NodeType::NEW, keyword);
	node.constructor.type = type;
	node.constructor.arguments = new Vector();

	if(this.match(TokenType::LEFT_PAREN)) {
		if(!this.check(TokenType::RIGHT_PAREN)) {
			do {
				var arg = this.parse_expression();

				node.constructor.arguments.push(arg);
			} while(this.match(TokenType::COMMA));
		}
		this.consume(TokenType::RIGHT_PAREN, "Expected ')' after constructor arguments");
	}
	else if(this.match(TokenType::LEFT_SQBR)) {
		var length = this.parse_expression();
		this.consume(TokenType::RIGHT_SQBR, "Expected ']' after array length");
		node.type = NodeType::NEW_ARRAY;
		node.constructor.array.length = length;
	}

	node.constructor.shouldConstruct = false;
	
	return node;
}

function Parser.parse_value(): Node* {
	if(this.match(TokenType::INT_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(NodeType::INT_LITERAL, literal);
		literalNode.literal.type = INT_TYPE;
		literalNode.literal.az.integer = atoi(literal.start);

		return literalNode;
	}
	else if(this.match(TokenType::UINT_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(NodeType::UINT_LITERAL, literal);
		literalNode.literal.type = UINT_TYPE;
		literalNode.literal.az.uinteger = atoui(literal.start);

		return literalNode;
	}
	else if(this.match(TokenType::CHAR_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(NodeType::CHAR_LITERAL, literal);
		literalNode.literal.type = I8_TYPE;
		literalNode.literal.az.integer = this.escape_character(literal);

		return literalNode;
	}
	else if(this.match(TokenType::FLOAT_LITERAL)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(NodeType::FLOAT_LITERAL, literal);
		literalNode.literal.type = F64_TYPE;

		var str = new i8[literal.length + 1];
		memcpy(str, literal.start, literal.length);
		str[literal.length] = 0;

		literalNode.literal.az.float.str = str;
		literalNode.literal.az.float.id = this.floats.size;

		this.floats.push(literalNode);
		return literalNode;
	}
	else if(this.match(TokenType::STRING)) {
		var literal = this.previous;
		if(this.error) return null;

		var literalNode = new_node(NodeType::STRING, literal);
		literalNode.literal.type = STR_TYPE;

		var buf = new i8[literal.length - 2 + 1];
		this.escape_string(literal, buf);

		literalNode.literal.az.string.chars = buf;
		literalNode.literal.az.string.length = literal.length - 2;
		literalNode.literal.az.string.id = this.strings.size;

		var str = this.find_string(literalNode);
		if(str == null) {
			this.strings.push(literalNode);
			return literalNode;
		}

		delete buf;
		delete literalNode;
		return str;
	}
	else if(this.match(TokenType::IDENTIFIER)) {
		return this.parse_identifier();
	}
	else if(this.match(TokenType::SIZEOF)) {
		var expr = new_node(NodeType::SIZEOF, this.previous);
		this.consume(TokenType::LEFT_PAREN, "Expected '(' after sizeof");
		var type = this.parse_type();
		this.consume(TokenType::RIGHT_PAREN, "Expected ')' after sizeof type");
		expr.computedType = type;
		return expr;
	}
	else if(this.match(TokenType::NEW)) {
		return this.parse_new();
	}
	else if(this.match(TokenType::LEFT_PAREN)) {
		var expr = this.parse_expression();
		this.consume(TokenType::RIGHT_PAREN, "Expected closing ')' after expression");
		return expr;
	}

	this.error_current("Expected value");
	return null;
}

function Parser.parse_member_access(): Node* {
	var left = this.parse_value();

	while(this.match(TokenType::LEFT_SQBR) || this.match(TokenType::DOT) || this.match(TokenType::INCREMENT) || this.match(TokenType::DECREMENT)) {
		var op = this.previous;

		if(op.type == TokenType::LEFT_SQBR) {
			var right = this.parse_expression();

			this.consume(TokenType::RIGHT_SQBR, "Expected ']' after subscript index");

			var subscript = new_node(NodeType::ACCESS_SUBSCRIPT, op);
			subscript.binary.lhs = left;
			subscript.binary.rhs = right;
			subscript.lvalue = LValue::SUBSCRIPT;
			left = subscript;
		}
		else if(op.type == TokenType::INCREMENT || op.type == TokenType::DECREMENT) {
			var type = op.type == TokenType::INCREMENT ? NodeType::POST_INCREMENT : NodeType::POST_DECREMENT;

			var postfix = new_node(type, op);
			postfix.unary = left;
			left = postfix;
			break;
		}
		else {
			var memberName = this.consume(TokenType::IDENTIFIER, "Expected member name");

			if(this.match(TokenType::LEFT_PAREN)) {
				var call = this.parse_call(memberName);
				call.type = NodeType::CALL_METHOD;
				this.bind_name(&call.funktion.name, memberName);
				call.funktion.isMethod = true;
				call.funktion.parent = left;
				left = call;
			}
			else {
				var member = new_node(NodeType::ACCESS_MEMBER, op);
				member.member.name = memberName;
				member.member.parent = left;
				member.lvalue = LValue::MEMBER;
				left = member;
			}
		}
	}

	return left;
}

function Parser.parse_unary(): Node* {
	if(this.match(TokenType::TILDE)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var bwnot = new_node(NodeType::BWNOT, op);
		bwnot.unary = expr;
		return bwnot;
	}
	else if(this.match(TokenType::MINUS)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var neg = new_node(NodeType::NEG, op);
		neg.unary = expr;
		return neg;
	}
	else if(this.match(TokenType::BANG)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var not = new_node(NodeType::NOT, op);
		not.unary = expr;
		return not;
	}
	else if(this.match(TokenType::AMP)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var addrOf = new_node(NodeType::ADDROF, op);
		addrOf.unary = expr;
		return addrOf;
	}
	else if(this.match(TokenType::STAR)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var deref = new_node(NodeType::DEREF, op);
		deref.unary = expr;
		deref.lvalue = LValue::DEREF;
		return deref;
	}
	else if(this.match(TokenType::INCREMENT)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var increment = new_node(NodeType::PRE_INCREMENT, op);
		increment.unary = expr;
		return increment;
	}
	else if(this.match(TokenType::DECREMENT)) {
		var op = this.previous;
		var expr = this.parse_unary();
		var decrement = new_node(NodeType::PRE_DECREMENT, op);
		decrement.unary = expr;
		return decrement;
	}

	return this.parse_member_access();
}

function Parser.parse_as_cast(): Node* {
	var left = this.parse_unary();

	if(this.match(TokenType::AS)) {
		var op = this.previous;
		var castTo = this.parse_type();

		var cast = new_node(NodeType::CAST, op);
		cast.unary = left;
		cast.computedType = castTo;
		left = cast;
	}

	return left;
}

function Parser.parse_term(): Node* {
	var left = this.parse_as_cast();

	while(this.match(TokenType::STAR) || this.match(TokenType::SLASH) || this.match(TokenType::PERCENT)) {
		var op = this.previous;

		var right = this.parse_as_cast();

		var type: int;
		if(op.type == TokenType::STAR) type = NodeType::MUL;
		else if(op.type == TokenType::SLASH) type = NodeType::DIV;
		else if(op.type == TokenType::PERCENT) type = NodeType::MOD;

		var binary = new_node(type, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_arithmetic(): Node* {
	var left = this.parse_term();

	while(this.match(TokenType::PLUS) || this.match(TokenType::MINUS)) {
		var op = this.previous;

		var right = this.parse_term();

		var type: int;
		if(op.type == TokenType::PLUS) type = NodeType::ADD;
		else if(op.type == TokenType::MINUS) type = NodeType::SUB;

		var binary = new_node(type, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_shift(): Node* {
	var left = this.parse_arithmetic();

	while(this.match(TokenType::LSH) || this.match(TokenType::RSH)) {
		var op = this.previous;

		var right = this.parse_arithmetic();

		var type: int;
		if(op.type == TokenType::LSH) type = NodeType::LSH;
		else if(op.type == TokenType::RSH) type = NodeType::RSH;

		var binary = new_node(type, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_comparison(): Node* {
	var left = this.parse_shift();

	while(this.match(TokenType::LESS) || this.match(TokenType::LEQ)
	     || this.match(TokenType::GREATER) || this.match(TokenType::GEQ)) {
		var op = this.previous;

		var right = this.parse_shift();

		var type: int;
		if(op.type == TokenType::LESS) type = NodeType::LESS;
		else if(op.type == TokenType::LEQ) type = NodeType::LESS_EQ;
		else if(op.type == TokenType::GREATER) type = NodeType::GREATER;
		else if(op.type == TokenType::GEQ) type = NodeType::GREATER_EQ;

		var binary = new_node(type, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_equality(): Node* {
	var left = this.parse_comparison();

	while(this.match(TokenType::EQEQ) || this.match(TokenType::BANG_EQ)) {
		var op = this.previous;

		var right = this.parse_comparison();

		var type: int;
		if(op.type == TokenType::EQEQ) type = NodeType::EQUAL;
		else if(op.type == TokenType::BANG_EQ) type = NodeType::NOT_EQUAL;

		var binary = new_node(type, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwand(): Node* {
	var left = this.parse_equality();

	while(this.match(TokenType::AMP)) {
		var op = this.previous;

		var right = this.parse_equality();

		var binary = new_node(NodeType::BWAND, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_xor(): Node* {
	var left = this.parse_bwand();

	while(this.match(TokenType::XOR)) {
		var op = this.previous;

		var right = this.parse_bwand();

		var binary = new_node(NodeType::XOR, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_bwor(): Node* {
	var left = this.parse_xor();

	while(this.match(TokenType::BAR)) {
		var op = this.previous;

		var right = this.parse_xor();

		var binary = new_node(NodeType::BWOR, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_and(): Node* {
	var left = this.parse_bwor();

	while(this.match(TokenType::AMP_AMP)) {
		var op = this.previous;

		var right = this.parse_bwor();

		var binary = new_node(NodeType::AND, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_or(): Node* {
	var left = this.parse_and();

	while(this.match(TokenType::BAR_BAR)) {
		var op = this.previous;

		var right = this.parse_and();

		var binary = new_node(NodeType::OR, op);
		binary.binary.lhs = left;
		binary.binary.rhs = right;
		left = binary;
	}

	return left;
}

function Parser.parse_ternary_expression(): Node* {
	var condition = this.parse_or();

	if(this.match(TokenType::QUESTION)) {
		var op = this.previous;
		var doTrue = this.parse_expression();

		this.consume(TokenType::COLON, "Expected ':' after true branch of ternary expression");

		var doFalse = this.parse_expression();

		var ternary = new_node(NodeType::TERNARY, op);
		ternary.conditional.condition = condition;
		ternary.conditional.doTrue = doTrue;
		ternary.conditional.doFalse = doFalse;
		return ternary;
	}

	return condition;
}

function Parser.parse_assignment_expression(): Node* {
	var left = this.parse_ternary_expression();

	while(is_assignment(this.current.type)) {
		this.advance();

		if(left.lvalue == LValue::NONE) {
			this.error("Invalid lvalue for assignment");
			return null;
		}

		var op = this.previous;

		var right = this.parse_assignment_expression();

		var assign = new_node(NodeType::ASSIGN, left.position);
		assign.assignment.lhs = left;
		assign.assignment.rhs = right;
		assign.assignment.op = op;
		left = assign;
	}

	return left;
}

function Parser.parse_expression(): Node* {
	return this.parse_assignment_expression();
}

function Parser.parse_if_statement(): Node* {
	var ifStmt = new_node(NodeType::IF, this.previous);

	this.consume(TokenType::LEFT_PAREN, "Expected '(' after if");

	ifStmt.conditional.condition = this.parse_expression();

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after if condition");

	ifStmt.conditional.doTrue = this.parse_statement();

	if(this.match(TokenType::ELSE)) {
		ifStmt.conditional.doFalse = this.parse_statement();
	}

	return ifStmt;
}

function Parser.parse_while_statement(): Node* {
	var whileStmt = new_node(NodeType::WHILE, this.previous);

	this.consume(TokenType::LEFT_PAREN, "Expected '(' after while");

	whileStmt.conditional.condition = this.parse_expression();

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after while condition");

	whileStmt.conditional.doTrue = this.parse_statement();

	return whileStmt;
}

function Parser.parse_do_while_statement(): Node* {
	var doStmt = new_node(NodeType::DO_WHILE, this.previous);

	doStmt.conditional.doTrue = this.parse_statement();

	this.consume(TokenType::WHILE, "Expected 'while' after do..while body");

	this.consume(TokenType::LEFT_PAREN, "Expected '(' after 'while'");

	doStmt.conditional.condition = this.parse_expression();

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after do..while condition");

	this.consume(TokenType::SEMICOLON, "Expected ';' after do..while");

	return doStmt;
}

function Parser.parse_for_statement(): Node* {
	var forStmt = new_node(NodeType::FOR, this.previous);

	var block = new_node(NodeType::BLOCK, this.previous);
	block.block.children = new Vector();
	block.block.parent = this.currentBlock;
	this.currentBlock = block;

	this.consume(TokenType::LEFT_PAREN, "Expected '(' after for");

	if(this.match(TokenType::SEMICOLON)) {
		// No initialiser clause
	}
	else if(this.match(TokenType::VAR)) {
		forStmt.loop.initial = this.parse_var_declaration();
	}
	else if(this.check(TokenType::IDENTIFIER)) {
		forStmt.loop.initial = this.parse_statement();
	}
	else {
		this.error_current("Expected for initializer clause");
	}

	if(!this.match(TokenType::SEMICOLON)) {
		forStmt.loop.condition = this.parse_expression();
		this.consume(TokenType::SEMICOLON, "Expected ';' after condition");
	}

	if(!this.match(TokenType::RIGHT_PAREN)) {
		forStmt.loop.iteration = this.parse_expression();
		this.consume(TokenType::RIGHT_PAREN, "Expected ')' after for clauses");
	}

	forStmt.loop.body = this.parse_statement();

	block.add_child(forStmt);

	this.currentBlock = block.block.parent;

	return block;
}

function Parser.parse_return_statement(): Node* {
	var returnStmt = new_node(NodeType::RETURN, this.previous);

	if(!this.check(TokenType::SEMICOLON))
		returnStmt.ret.value = this.parse_expression();

	this.consume(TokenType::SEMICOLON, "Expected ';' after return statement");

	return returnStmt;
}

function Parser.parse_array_initialization(): Node* {
	var array = new_node(NodeType::ARRAY_INIT, this.previous);
	array.block.children = new Vector();

	if(!this.check(TokenType::RIGHT_SQBR)) {
		do {
			var item = this.parse_expression();
			array.add_child(item);
		} while(this.match(TokenType::COMMA));
	}
	this.consume(TokenType::RIGHT_SQBR, "Expected ']' after array initialization");
	return array;
}

function Parser.parse_var_declaration(): Node* {
	var name = this.consume(TokenType::IDENTIFIER, "Expected variable name");

	var type = VOID_TYPE;

	if(this.match(TokenType::COLON)) {
		type = this.parse_type();
	}

	var variable = new_node(NodeType::DEFINE_VAR, name);
	this.bind_name(&variable.variable.name, name);
	variable.variable.type = type;
	variable.variable.value = null;
	variable.variable.arguments = null;

	if(this.match(TokenType::EQ)) {
		if(type.isArray && this.match(TokenType::LEFT_SQBR)) {
			variable.variable.value = this.parse_array_initialization();
		}
		else {
			variable.variable.value = this.parse_expression();
		}
	}

	else if(type != VOID_TYPE && this.match(TokenType::LEFT_PAREN)) {
		variable.variable.arguments = new Vector();
		if(!this.check(TokenType::RIGHT_PAREN)) {
			var arg = this.parse_expression();

			variable.variable.arguments.push(arg);

			while(this.match(TokenType::COMMA)) {
				var arg = this.parse_expression();

				variable.variable.arguments.push(arg);
			}
		}

		this.consume(TokenType::RIGHT_PAREN, "Expected ')' after constructor arguments");
	}

	this.consume(TokenType::SEMICOLON, "Expected ';' after variable declaration");

	return variable;
}

function Parser.parse_when_statement(): Node* {
	var vhenTok = this.previous;
	this.consume(TokenType::LEFT_PAREN, "Expected '(' after when");

	var match = this.parse_expression();

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after when match");

	this.consume(TokenType::LEFT_BRACE, "Expected '{' before when branches");

	if(this.match(TokenType::RIGHT_BRACE)) this.error("Expected at least one when branch");

	var vhen = new_node(NodeType::WHEN, vhenTok);
	vhen.vhen.match = match;
	vhen.vhen.branches = new Vector();

	while(!this.check(TokenType::RIGHT_BRACE)) {
		if(this.match(TokenType::ELSE)) {
			this.consume(TokenType::ARROW, "Expected '->' after else");
			vhen.vhen.default = this.parse_statement();
			break;
		}

		var branch = new_node(NodeType::BRANCH, this.current);
		branch.branch.values = new Vector();

		var value = this.parse_constant();
		branch.branch.values.push(value as any*);

		while(this.match(TokenType::COMMA)) {
			var value = this.parse_constant();
			branch.branch.values.push(value as any*);
		}

		var arrow = this.consume(TokenType::ARROW, "Expected '->' after branch value");

		branch.position = arrow;

		var body = this.parse_statement();
		branch.branch.body = body;

		vhen.vhen.branches.push(branch);
	}

	this.consume(TokenType::RIGHT_BRACE, "Expected '}' after when branches");

	return vhen;
}

function Parser.parse_delete_statement(): Node* {
	var keyword = this.previous;

	var expr = this.parse_expression();
	
	this.consume(TokenType::SEMICOLON, "Expected ';' after delete expression");

	var node = new_node(NodeType::DELETE, keyword);
	node.deconstructor.value = expr;
	node.deconstructor.shouldDeconstruct = false;
	return node;
}

function Parser.parse_delete_array_statement(): Node* {
	var keyword = this.previous;

	var expr = this.parse_expression();
	
	this.consume(TokenType::SEMICOLON, "Expected ';' after delete[] expression");

	var node = new_node(NodeType::DELETE_ARRAY, keyword);
	node.deconstructor.value = expr;
	node.deconstructor.shouldDeconstruct = false;
	return node;
}

function Parser.parse_statement(): Node* {
	if(this.match(TokenType::BREAK)) {
		var pos = this.previous;
		this.consume(TokenType::SEMICOLON, "Expected ';' after 'break'");
		var breac = new_node(NodeType::BREAK, pos);
		return breac;
	}
	else if(this.match(TokenType::CONTINUE)) {
		var pos = this.previous;
		this.consume(TokenType::SEMICOLON, "Expected ';' after 'continue'");
		var kontinue = new_node(NodeType::CONTINUE, pos);
		return kontinue;
	}
	else if(this.match(TokenType::DELETE)) {
		return this.parse_delete_statement();
	}
	else if(this.match(TokenType::DELETE_ARRAY)) {
		return this.parse_delete_array_statement();
	}
	else if(this.match(TokenType::DO)) {
		return this.parse_do_while_statement();
	}
	else if(this.match(TokenType::IF)) {
		return this.parse_if_statement();
	}
	else if(this.match(TokenType::FOR)) {
		return this.parse_for_statement();
	}
	else if(this.match(TokenType::RETURN)) {
		return this.parse_return_statement();
	}
	else if(this.match(TokenType::VAR)) {
		return this.parse_var_declaration();
	}
	else if(this.match(TokenType::WHEN)) {
		return this.parse_when_statement();
	}
	else if(this.match(TokenType::WHILE)) {
		return this.parse_while_statement();
	}
	else if(this.match(TokenType::LEFT_BRACE)) {
		return this.parse_block();
	}

	var expr = this.parse_expression();

	if(expr == null) return null;

	if(!allow_expr_stmt(expr)) {
		this.error("Expected statement");
		return null;
	}

	this.consume(TokenType::SEMICOLON, "Expected ';' after expression");

	var exprStmt = new_node(NodeType::EXPR_STMT, expr.position);
	exprStmt.unary = expr;

	return exprStmt;
}

function Parser.parse_block(): Node* {
	var block = new_node(NodeType::BLOCK, this.previous);
	block.block.children = new Vector();
	block.block.parent = this.currentBlock;
	this.currentBlock = block;

	while(!this.check(TokenType::RIGHT_BRACE)) {
		var stmt = this.parse_statement();
		if(this.error) break;
		block.add_child(stmt);
	}

	this.consume(TokenType::RIGHT_BRACE, "Expected '}' after block");

	this.currentBlock = block.block.parent;
	return block;
}

function Parser.parse_function(): Node* {
	var name = this.consume(TokenType::IDENTIFIER, "Expected function name");

	var funktion = new_node(NodeType::FUNCTION, name);
	funktion.funktion.arguments = new Vector();

	var nameSpace = new_namespace(null, null);
	nameSpace.parts = new Vector();

	while(this.match(TokenType::COLON_COLON)) {
		nameSpace.parts.push(name);
		name = this.consume(TokenType::IDENTIFIER, "Expected identifier");
	}

	if(this.match(TokenType::DOT)) {
		var parentName: Name;
		this.bind_name(&parentName, name);
		if(nameSpace.parts.size > 0) bind_to_namespace(&parentName, nameSpace);

		var parent = this.lookup_type(&parentName);
		if(parent == null) return null;

		funktion.funktion.parentType = parent;
		funktion.funktion.isMethod = true;
		var methodName = this.consume(TokenType::IDENTIFIER, "Expected function name");

		var synthThis = synthetic_token(TokenType::IDENTIFIER, "this");
		var type = new Type;
		type.type = DataType::UNRESOLVED;
		this.bind_name(&type.name, name);
		if(nameSpace.parts.size > 0) bind_to_namespace(&type.name, nameSpace);

		type.indirection = 1;

		var thisNode = new_node(NodeType::DEFINE_VAR, synthThis);
		this.bind_name(&thisNode.variable.name, synthThis);
		thisNode.variable.type = type;

		funktion.funktion.arguments.push(thisNode);
		
		name = methodName;
	}
	else if(nameSpace.parts.size > 0) {
		this.error("Cannot declare function inside another namespace");
	}

	if(!funktion.funktion.isMethod) {
		this.namespace_name(&funktion.funktion.name, name);
		
		this.add_function(funktion);
	} else {
		this.bind_name(&funktion.funktion.name, name);

		funktion.funktion.parentType.add_method(funktion);
	}
	
	this.consume(TokenType::LEFT_PAREN, "Expected '(' after function name");
	
	if(!this.check(TokenType::RIGHT_PAREN)) {
		do {
			var argName = this.consume(TokenType::IDENTIFIER, "Expected parameter name");
			this.consume(TokenType::COLON, "Expected ':' after parameter name");
			var type = this.parse_type();

			var arg = new_node(NodeType::DEFINE_VAR, argName);
			this.bind_name(&arg.variable.name, argName);
			arg.variable.type = type;

			funktion.funktion.arguments.push(arg);
		} while(this.match(TokenType::COMMA));
	}

	this.consume(TokenType::RIGHT_PAREN, "Expected ')' after function parameters");

	var type: Type*;

	if(this.match(TokenType::COLON)) {
		type = this.match(TokenType::VOID) ? VOID_TYPE : this.parse_type();
	}
	else {
		type = VOID_TYPE;
	}

	this.consume(TokenType::LEFT_BRACE, "Expected '{' before function body");

	funktion.funktion.returnType = type;

	this.currentFunction = funktion;

	var body = this.parse_block();

	funktion.funktion.body = body;

	return funktion;
}

function Parser.parse_member_definition(type: Type*) {
	var memName = this.consume(TokenType::IDENTIFIER, "Expected member name");

	this.consume(TokenType::COLON, "Expected ':' after member name");

	if(this.match(TokenType::UNION)) {
		var vnion = this.parse_union_definition(true);

		this.consume(TokenType::SEMICOLON, "Expected ';' after member declaration");

		this.bind_name(&vnion.variable.name, memName);
		this.bind_name(&vnion.computedType.name, memName);

		var member = new_node(NodeType::MEMBER, memName);
		this.bind_name(&member.variable.name, memName);
		member.variable.type = vnion.computedType;
		member.variable.value = vnion;

		type.fields.push(member);
	}
	else if(this.match(TokenType::STRUCT)) {
		var strukt = this.parse_struct_definition(true);

		this.consume(TokenType::SEMICOLON, "Expected ';' after member declaration");

		this.bind_name(&strukt.variable.name, memName);
		this.bind_name(&strukt.computedType.name, memName);

		var member = new_node(NodeType::MEMBER, memName);
		this.bind_name(&member.variable.name, memName);
		member.variable.type = strukt.computedType;
		member.variable.value = strukt;

		type.fields.push(member);
	}
	else {
		var memType = this.parse_type();

		this.consume(TokenType::SEMICOLON, "Expected ';' after member declaration");

		var member = new_node(NodeType::MEMBER, memName);
		this.bind_name(&member.variable.name, memName);
		member.variable.type = memType;

		type.fields.push(member);
	}
}

function Parser.parse_struct_definition(member: int): Node* {
	var name: Token*;

	var strukt = new_node(NodeType::STRUCT, name);

	if(!member) {
		name = this.consume(TokenType::IDENTIFIER, "Expected struct name");
		this.namespace_name(&strukt.variable.name, name);
		
		var redef = Typecheck::lookup_type_defined(&strukt.variable.name, this.definedTypes, this.namespaceStack);
		if(redef != null) {
			this.error("Redeclaration of type");
		}
	}

	this.consume(TokenType::LEFT_BRACE, "Expected '{' before struct body");

	if(this.match(TokenType::RIGHT_BRACE)) this.error("Expected at least one struct member");

	var structType = new Type;
	structType.type = DataType::STRUCT;
	if(!member)
		this.namespace_name(&structType.name, name);
	else
		this.bind_name(&structType.name, name);

	structType.fields = new Vector();
	structType.methods = new std::map::HashMap;

	do {
		if(this.match(TokenType::UNION)) {
			var vnion = this.parse_union_definition(true);
			for(var i = 0; i < vnion.computedType.fields.size; i = i + 1) {
				var member: Node* = vnion.computedType.fields.at(i);
				member.variable.unionField = true;
				structType.fields.push(member);
			}

			this.consume(TokenType::SEMICOLON, "Expected ';' after member declaration");

			continue;
		}

		this.parse_member_definition(structType);
	} while(!this.check(TokenType::RIGHT_BRACE));

	this.consume(TokenType::RIGHT_BRACE, "Expected '}' after struct body");

	strukt.computedType = structType;

	if(!member) {
		this.definedTypes.push(structType);
	}

	return strukt;
}

function Parser.parse_union_definition(member: int): Node* {
	var name: Token*;

	var vnion = new_node(NodeType::UNION, name);
	
	if(!member) {
		name = this.consume(TokenType::IDENTIFIER, "Expected union name");
		this.namespace_name(&vnion.variable.name, name);

		var redef = Typecheck::lookup_type_defined(&vnion.variable.name, this.definedTypes, this.namespaceStack);
		if(redef != null) {
			this.error("Redeclaration of type");
		}
	}

	this.consume(TokenType::LEFT_BRACE, "Expected '{' before union body");

	if(this.match(TokenType::RIGHT_BRACE)) this.error("Expected at least one union member");

	var unionType = new Type;
	unionType.type = DataType::UNION;
	if(!member)
		this.namespace_name(&unionType.name, name);
	else
		this.bind_name(&unionType.name, name);
	unionType.fields = new Vector();

	do {
		this.parse_member_definition(unionType);
	} while(!this.check(TokenType::RIGHT_BRACE));

	this.consume(TokenType::RIGHT_BRACE, "Expected '}' after union body");

	vnion.computedType = unionType;

	if(!member) {
		this.definedTypes.push(unionType);
	}

	return vnion;
}

function Parser.parse_const_declaration(): Node* {
	var name = this.consume(TokenType::IDENTIFIER, "Expected constant name");

	var constant = new_node(NodeType::DEFINE_CONST, name);
	this.namespace_name(&constant.constant.name, name);

	if(this.lookup_constant(&constant.constant.name) != null) {
		this.error("Redeclaration of constant");
	}

	this.consume(TokenType::EQ, "Expected '=' after constant name");

	var val = this.parse_constant();

	this.consume(TokenType::SEMICOLON, "Expected ';' after constant declaration");

	constant.constant.value = val;

	this.constants.push(constant);

	return constant;
}

function Parser.parse_enum_declaration(): Node* {
	var name = this.consume(TokenType::IDENTIFIER, "Expected enum name");

	this.consume(TokenType::LEFT_BRACE, "Expected '{' after enum name");

	var nameSpace = new_namespace(name, this.namespaceStack.empty() ? null : this.namespaceStack.top());

	this.namespaceStack.push(nameSpace);

	var namespaceNode = new_node(NodeType::NAMESPACE, name);
	namespaceNode.nameSpace.name = nameSpace;
	var namespaceBody = new_node(NodeType::BLOCK, name);
	namespaceBody.block.children = new Vector();
	namespaceNode.nameSpace.body = namespaceBody;

	var envm = new_node(NodeType::ENUM, name);
	envm.block.children = new Vector();

	var count = 0;

	do {
		var constantName = this.consume(TokenType::IDENTIFIER, "Expected constant name");

		var constant = new_node(NodeType::DEFINE_CONST, name);
		this.namespace_name(&constant.constant.name, constantName);
		constant.constant.value = count;

		this.constants.push(constant);

		envm.block.children.push(constant);

		count = count + 1;
	} while(this.match(TokenType::COMMA));

	this.consume(TokenType::RIGHT_BRACE, "Expected '}' after enum body");

	namespaceBody.add_child(envm);

	this.namespaceStack.pop();

	var alius = new Type;
	alius.type = DataType::ALIAS;
	this.namespace_name(&alius.name, name);
	alius.aliased = INT_TYPE;

	if(Typecheck::lookup_type_defined(&alius.name, this.definedTypes, this.namespaceStack) != null) {
		this.error_at_token(name, "Redeclaration of type");
	}

	this.definedTypes.push(alius);

	return namespaceNode;
}

function Parser.parse_import() {
	var path = this.consume(TokenType::STRING, "Expected import path");
	this.consume(TokenType::SEMICOLON, "Expected ';' after import");

	var spath = new i8[path.length - 2 + 1];
	memcpy(spath, &path.start[1], path.length - 2);
	spath[path.length - 2] = 0;

	for(var i = 0; i < this.lexerStack.size; ++i) {
		var lexer: Lexer* = this.lexerStack.at(i);

		if(streq(spath, lexer.filename)) {
			this.error("Circular import detected");
			return;
		}
	}

	for(var i = 0; i < this.openedFiles.size; ++i) {
		if(streq(spath, this.openedFiles.at(i))) {
			// Do nothing: already opened
			return;
		}
	}

	var file = fopen(spath, 'r');
	if(file == null) {
		putsln(spath);
		this.error_at_token(path, "Could not open file");
		return;
	}
	var source = file.slurp(null);
	file.close();

	var lexer = new_lexer(spath, source);

	this.lexerStack.push(lexer);
	this.openedFiles.push(spath);

	this.lexer = lexer;
	this.advance();
}

function Parser.parse_alias() {
	var aliasName = this.consume(TokenType::IDENTIFIER, "Expected alias name");
	var aliasType = this.parse_type();

	this.consume(TokenType::SEMICOLON, "Expected ';' after alias");

	var alius = new Type;
	alius.type = DataType::ALIAS;
	this.namespace_name(&alius.name, aliasName);
	alius.aliased = aliasType;

	if(Typecheck::lookup_type_defined(&alius.name, this.definedTypes, this.namespaceStack) != null) {
		this.error_at_token(aliasName, "Redeclaration of type");
	}

	this.definedTypes.push(alius);
}

function Parser.parse_namespace(): Node* {
	var namespaceName = this.consume(TokenType::IDENTIFIER, "Expected namespace name");
	var nameSpace = new_namespace(namespaceName, this.namespaceStack.empty() ? null : this.namespaceStack.top());

	while(this.match(TokenType::COLON_COLON)) {
		namespaceName = this.consume(TokenType::IDENTIFIER, "Expected identifier");
		nameSpace.parts.push(namespaceName);
	}

	this.namespaceStack.push(nameSpace);

	this.consume(TokenType::LEFT_BRACE, "Expected '{' after namespace name");

	var namespaceNode = new_node(NodeType::NAMESPACE, namespaceName);

	var body = new_node(NodeType::BLOCK, this.previous);
	body.block.children = new Vector();

	namespaceNode.nameSpace.name = nameSpace;
	namespaceNode.nameSpace.body = body;

	while(!this.match(TokenType::RIGHT_BRACE)) {
		this.parse_top_level_declaration(body);
	}

	this.namespaceStack.pop();

	return namespaceNode;
}

function Parser.parse_top_level_declaration(block: Node*) {
	if(this.match(TokenType::FUNCTION)) {
		var funktion = this.parse_function();
		block.add_child(funktion);
	}
	else if(this.match(TokenType::VAR)) {
		var variable = this.parse_var_declaration();
		variable.type = NodeType::DEFINE_GLOBAL_VAR;
		this.bind_namespace(&variable.variable.name);
		block.add_child(variable);
	}
	else if(this.match(TokenType::CONST)) {
		var constant = this.parse_const_declaration();
		block.add_child(constant);
	}
	else if(this.match(TokenType::STRUCT)) {
		var strukt = this.parse_struct_definition(false);
		block.add_child(strukt);
	}
	else if(this.match(TokenType::UNION)) {
		var vnion = this.parse_union_definition(false);
		block.add_child(vnion);
	}
	else if(this.match(TokenType::ENUM)) {
		var envm = this.parse_enum_declaration();
		block.add_child(envm);
	}
	else if(this.match(TokenType::NAMESPACE)) {
		var nameSpace = this.parse_namespace();
		block.add_child(nameSpace);
	}
	else if(this.match(TokenType::ALIAS)) {
		this.parse_alias();
	}
	else {
		this.error_current("Expected definition");
	}
}

function Parser.parse_program(): Node* {
	var program = new_node(NodeType::PROGRAM, this.current);
	program.block.children = new Vector();

	this.advance();

	var builtins = parser_builtin_functions();

	for(var i = 0; i < builtins.size; ++i) {
		this.add_function(builtins.at(i));
	}

	this.lexerStack.push(this.lexer);

	while(!this.match(TokenType::EOF)) {
		if(this.match(TokenType::IMPORT)) {
			this.parse_import();
		}
		else {
			this.parse_top_level_declaration(program);
		}

		if(this.error) break;

		var tok = this.current;
		var changedLexer = false;
		while(tok.type == TokenType::EOF && this.lexerStack.size > 1) {
			changedLexer = true;
			this.lexerStack.pop();
			this.lexer = this.lexerStack.at(this.lexerStack.size - 1);
			tok = this.peek();
		}
		if(changedLexer) {
			this.advance();
		}
	}

	return program;
}